<?php
/**
 * @file
 * Module to emulate Slashdot comment system
 */

// Commnet flat and trheaded display
define('SLASHCOMMENTS_MODE_FLAT', 2);
define('SLASHCOMMENTS_MODE_THREADED', 4);

// Comment default rating  */
define('SLASHCOMMENTS_DEFAULT_RATING', 1);
define('SLASHCOMMENTS_DEFAULT_RATING_ANONYMOUS', 0);

// Comment default rating  */
define('SLASHCOMMENTS_DEFAULT_THRESHOLD', 1);

// Settings:
//  limit moderation from participating users
define('SLASHCOMMENTS_LIMIT_TAKEPART', 1);
// delete moderation from participating users
define('SLASHCOMMENTS_DELETE_TAKEPART', 0);
// days before newbie users can post
define('SLASHCOMMENTS_LIMIT_NEWBIE', 14);
// enable karma
define('SLASHCOMMENTS_ENABLE_KARMA', 0);
// limit moderation based on karma value
define('SLASHCOMMENTS_LIMIT_KARMA', 0);
// initial karma value
define('SLASHCOMMENTS_DEFAULT_KARMA', 1);
// numbers of moderated comment for having karma
define('SLASHCOMMENTS_RATINGS_FOR_KARMA', 0);

/**
 * Implementation of hook_init().
 */
function slashcomments_init() {

  // add base url and other needed js variables
  drupal_add_js(
    array('baseUrl'  => $GLOBALS['base_url'],
    'slashdot' => array('error_status' => t("Error moderationg comment"),
    'load_image_path' => $GLOBALS['base_url'] . '/' . drupal_get_path('module', 'slashcomments') . 'images/loading.gif')
  ),
  'setting'
);
}

/**
 * Implementation of hook_views_api().
 */
function slashcomments_views_api() {
  return array('api' => 2.0,
               'path' => drupal_get_path('module', 'slashcomments') . '/includes/views');
}

/**
 * Implementation of hook_perm().
 */
function slashcomments_perm() {
  return array('moderate comments','administer slashcomments');
}

/**
 * Implementation of hook_menu().
 */
function slashcomments_menu() {
  $items = array();

  // Add the callback for AJAX moderation
  $items['slashdot/moderate'] = array(
    'title' => 'Slashcomments - AJAX moderation',
    'page callback' => 'slashdotcomments_moderate',
    'access callback' => 'slashcomments_moderate_access',
    'type' => MENU_CALLBACK,
  );

  // Add the callback for settings menÃ¹
  $items['admin/settings/slashcomments'] = array(
    'title' => 'Slashcomments',
    'description' => 'Configure slashcomments',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_general'),
    'access arguments' => array('administer slashcomments'),
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  $items['admin/settings/slashcomments/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implementation of access callback
 */
function slashcomments_moderate_access() {
  return user_access('access content') && user_access('moderate comments');
}

/**
 * Implemente the callback for slashdot/moderate menu entry responsible
 * of hnandling AJAX modration
 */
function slashdotcomments_moderate() {
  global $user;

  // Check needed variable has been sent
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])
    || !is_numeric($_POST['uid']) || !is_numeric($_POST['vote']) ) {
      return;
    }
  // save the vote
  if (!slashcomments_store_vote($_POST['cid'], $_POST['vote'])) {
    return;
  }

  // Get the new rating for the moderated comment
  $rating = slashcomments_get_comment_rating($_POST['cid']);

  // Create the string representation of the rating
  $description = isset($rating['description']) ? ' '. $rating['description'] : '';
  $rating_str = '(' . t('Score') . ':' . $rating['rating'] . $description . ')';

  // Set variable to be used by ajax success hander
  drupal_json(array(
    'rating' => $rating_str,
    'status' => t('Comment moderated!')
  ));
  exit();
}

/**
 * Submit function for comment moderation form, called if AJAX moderation is off
 */
function slashcomments_moderation_form_submit($form, &$form_state) {
  slashcomments_store_vote($form_state['values']['cid'], $form_state['values']['vote']);

}

/**
 * Store a moderation vote
 */
function slashcomments_store_vote($cid, $vote) {
  global $user;
  $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));

  // Check if user is allowed to vote
  if (!slashcomments_user_can_vote($user->uid, $cid)) {
    return FALSE;
  }

  // Build vote object
  $vote  = array(
    'content_type'    => 'comment',
    'content_id'      => $cid,
    'value_type'      => 'option',
    'value'           => $vote,
    'tag'             => 'slashcomments',
  );

  // Cast the vote and recalculate score and rating for the comment
  votingapi_add_votes($vote);
  votingapi_recalculate_results('comment', $cid, TRUE);

  slashcomments_update_rating($cid);

  // If karma is enabled updated its value
  if (_slashcomments_karma_enabled()) {
    slashcomments_update_karma($author_uid);
  }

  return TRUE;
}

/**
 * Implementation of hook_theme().
 */
function slashcomments_theme() {
  $items['slashcomments_comment'] = array(
    'template' => 'slashcomments-comment',
  );

  $items['slashcomments_moderation_form'] = array(
    'arguments' => array('form' => NULL),
  );

  return $items;
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function slashcomments_theme_registry_alter($theme_registry) {
  // replace the theme function for comment_view */
  if (!empty($theme_registry['comment_view'])) {
    $theme_registry['comment_view']['function'] = 'slashcomments_comment_view';
  }

  // replace the theme function for collapsed view with expanded view */
  if (!empty($theme_registry['comment_flat_collapsed'])) {
    $theme_registry['comment_flat_collapsed']['function'] = 'theme_comment_flat_expanded';
  }
  if (!empty($theme_registry['comment_thread_collapsed'])) {
    $theme_registry['comment_thread_collapsed']['function'] = 'theme_comment_thread_expanded';
  }

  // Code ported from the advanced forum module
  // --- The following section manipulates the theme registry so the .tpl files
  // --- for the given templates can be found first in the (sub)theme directory
  // --- then in ancestor themes, if any, and finally in the slashcomments folder.

  // Affected templates

  $templates = array('comment', 'author_pane');

  // Find all our ancestor themes and put them in an array.
  global $theme;
  $themes = list_themes();

  $ancestor_paths = array();
  $ancestor = $theme;
  while ($ancestor && isset($themes[$ancestor]->base_theme)) {
    array_unshift($ancestor_paths, dirname($themes[$themes[$ancestor]->base_theme]->filename));
    $ancestor = $themes[$ancestor]->base_theme;
  }
  $module_path = drupal_get_path('module', 'slashcomments') . '/templates';

  foreach ($templates as $template) {
    // Sanity check in case the template is not being used.
    if (is_array($theme_registry[$template])) {
      // If there was a path in there, store it.
      $existing_path = array_shift($theme_registry[$template]['theme paths']);
      array_unshift($theme_registry[$template]['theme paths'], $existing_path, $module_path);

      // If there are any ancestor paths (ie: we are in a subtheme, add those)
      foreach ($ancestor_paths as $ancestor_path) {
        $theme_registry[$template]['theme paths'][] = $ancestor_path;
      }
      //Put the active theme's path last since that takes precidence.
      $theme_registry[$template]['theme paths'][] = path_to_theme();
    }
  }
}


/** 
 * Get the template file to use for comments
 */
function _slashcomments_get_comment_template($used_tpl_file) {

  $tpl_files = array (
    "advf-forum-post"       => "slashcomments-advf-post-1x",
    "advanced_forum.post"   => "slashcomments-advf-post-2x"
  );

  return ($tpl_files[$used_tpl_file]) ? $tpl_files[$used_tpl_file] : "slashcomments-comment";
}


/* Retrieve the right template for comments and set it */
function _slashcomments_set_comment_template(&$variables) {
  static $new_tpl_file;

  if(empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_comment_template($used_tpl_file);
    _slashcomments_add_comment_template_files($new_tpl_file);
  }
  $variables['template_files'][] = $new_tpl_file;

}

function _slashcomments_add_comment_template_files($new_tpl_file) {
  drupal_add_js(drupal_get_path('module', 'slashcomments') .'/scripts/slashcomments.js');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/slashcomments.css');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
}

/**
 * Preprocesses template variables for the comment template.
 */
function slashcomments_preprocess_comment(&$variables) {
  _slashcomments_set_comment_template($variables);
  $comment = $variables['comment'];
  // get score and rating
  $rating = slashcomments_get_comment_rating($comment->cid);

  $description = isset($rating['description']) ? ' '. $rating['description'] : '';
  $variables['rating'] = '(' . t('Score') . ':' . $rating['rating'] . $description . ')';

  // get default threshold for the content type
  $threshold = _slashcomments_get_display_setting('threshold', $variables['node']);

  // fill out template variables
  if ($rating['rating'] >= $threshold) {
    $variables['collapsed'] = '';
    $variables['toggle_label'] = 'non_toggle_label';
    $variables['toggle_area'] = 'non_toggle_area';
  }
  else {
    $variables['collapsed'] = 'collapsed';
    $variables['toggle_label'] = 'toggle_label';
    $variables['toggle_area'] = 'toggle_area';
  }
  $variables['toggle_label'] .= ' ' . $comment->own;
  $variables['toggle_area'] .= ' ' . $comment->own;

  // generate permalink

  $page_number = $_GET['page'];

  if (!$page_number) {
    $page_number = 0;
  }

  $fragment = 'comment-' . $variables['comment']->cid;
  $query = ($page_number) ? 'page=' . $page_number : NULL;
  $img_path = drupal_get_path('module', 'slashcomments') . '/images';
  $linktext = '<img src="' . url($img_path) . '/permalink.gif" />';
  $linkpath = 'node/' . $variables['node']->nid;
  $variables['comment_link'] = l($linktext, $linkpath, array('query' => $query, 'fragment' => $fragment, 'html' => TRUE));

  // Link to page created by Comment Page module, if it exists
  $variables['page_link'] = '';
  if (!empty($variables['comment']->page_url) && !(arg(0) == 'comment' && arg(1) == $variables['comment']->cid)) {
    $variables['page_link'] = l(t('(permalink)'), $variables['comment']->page_url);
  }
}

/**
 * Provides implementation for theme_comment_view() override
 */
function slashcomments_comment_view($comment, $node, $links = array(), $visible = TRUE) {
  static $first_new = TRUE;
  $output = '';
  $comment->new = node_mark($comment->nid, $comment->timestamp);
  if ($first_new && $comment->new != MARK_READ) {
    // Assign the anchor only for the first new comment. This avoids duplicate
    // id attributes on a page.
    $first_new = FALSE;
    $output .= "<a id=\"new\"></a>\n";
  }

  //$output .= "<a id=\"comment-$comment->cid\"></a>\n";
  $comment->comment = check_markup($comment->comment, $comment->format, FALSE);

  // Comment API hook
  comment_invoke_comment($comment, 'view');
  $output .= theme('comment', $comment, $node, $links);
  return $output;
}

/**
 * Implementation of hook_comment().
 */
function slashcomments_comment($comment, $op) {
  switch ($op) {
  case 'view':
    global $user;
    $reply = arg(0) == 'comment' && (arg(1) == 'reply' || arg(1) == 'edit');
    // Hide moderation module if user can't moderate or is on the edit or reply page
    if (!$reply && slashcomments_user_can_vote($user->uid, $comment->cid)) {
      $comment->comment = $comment->comment . drupal_get_form('slashcomments_moderation_form', $comment->cid, $comment->uid);
    }

    // marke comments of the user in order to theme them differently
    if ($user->uid == $comment->uid && $user->uid != 0) {
      $comment->own = "own";
    }
    break;
  case 'insert':
    // if the user has moderated comments for this node before posting ots previous
    // moderation are removed
    if (variable_get('slashcomments_delete_takepart', SLASHCOMMENTS_DELETE_TAKEPART) == 1) {
      slashcomments_delete_user_comment_moderation($comment['nid'], $comment['uid']);
    }
    // if karma is enable apply a modifier to the initial comment rating
    if (_slashcomments_karma_enabled()) {
      slashcomments_init_contents_karma($comment['cid'], $comment['uid']);
    }

    break;
    // If the comment has been removed, delete infos about
    // is score and rating and update author karma
  case 'delete':
    $delete_votes = "DELETE FROM {votingapi_vote}
      WHERE content_id = %d
      AND tag = 'slashcomments'";

    db_query($delete_votes, $comment->cid);
    if (db_affected_rows() < 1) {
      break;
    }

    votingapi_recalculate_results('comment', $comment->cid, TRUE);
    slashcomments_delete_rating($comment->cid);
    slashcomments_update_karma($comment->uid);
    break;
  }
}

/**
 * Delete ratings for a single comment
 */
function slashcomments_delete_rating($cid) {
  db_query("DELETE FROM {slashcomments_ratings} WHERE cid = %d", $cid);
}

/**
 * Add threshold to comments control forms
 */
function slashcomments_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form') {
    unset($form['comment_filter']['comment']['#title']);
  }

  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $form['comment']['comment_default_threshold'] = array(
      '#type' => 'select',
      '#title' => t('Default comments threshold'),
      '#default_value' => variable_get('comment_default_threshold_'. $form['#node_type']->type, SLASHCOMMENTS_DEFAULT_THRESHOLD),
      '#options' => _slashcomments_thresholds(),
      '#description' => t('Default threshold for comments. Comments with lower score will be collapsed.'),
      '#weight' => -5,
    );
    $form['comment']['comment_default_mode'] = array(
      '#type' => 'select',
      '#title' => t('Default display mode'),
      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, SLASHCOMMENTS_MODE_FLAT),
      '#options' => _slashcomments_modes(),
      '#description' => t('The default view for comments.'),
      '#weight' => -4,
    );
    $form['comment']['comment_default_per_page']['#weight'] = -3;
    //order is always oldest first
    unset($form['comment']['comment_default_order']);
  }
  if ($form_id == 'comment_controls') {
    // WARNING: we cannot get node type from form info, so, we have to load from arg(1)
    $node = node_load(arg(1));

    $form['threshold'] = array(
      '#type' => 'select',
      '#title' => t('Threshold'),
      '#options' => _slashcomments_thresholds($node),
      '#default_value' => _slashcomments_get_display_setting('threshold', $node),
      '#weight' => 0,
    );

    $form['mode'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('mode', $node),
      '#options' => _slashcomments_modes(),
      '#weight' => 1,
    );

    //order is always oldest first
    $form['order'] = array(
      '#type' => 'hidden',
      '#value' => COMMENT_ORDER_OLDEST_FIRST,
    );

    $form['comments_per_page'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('comments_per_page', $node),
      '#options' => _slashcomments_per_page(),
      '#weight' => 3,
    );

    $form['#submit'][] = 'slashcomments_comment_control_submit';
  }
}


/**
 * Convertratings numeric options to descriptions
 */
function slashcomments_rating2description($rating) {
  static $descriptions;

  $descriptions = _slashcomments_moderation_options();
  if ($descriptions[$rating]) {
    return $descriptions[$rating];
  }
}

/**
 * Submit function for comment control form
 */
function slashcomments_comment_control_submit($form, &$form_state) {
  global $user;
  $threshold = $form_state['values']['threshold'];
  $mode = $form_state['values']['mode'];
  $order = $form_state['values']['order'];
  $comments_per_page = $form_state['values']['comments_per_page'];

  if ($user->uid) {
    $account = user_save($user, array('threshold' => $threshold, 'mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }
  }

  $_SESSION['comment_threshold'] = $threshold;
  $_SESSION['comment_mode'] = $mode;
  $_SESSION['comment_sort'] = $order;
  $_SESSION['comment_comments_per_page'] = $comments_per_page;
}

/**
 * Get display settings for a given content
 */
function _slashcomments_get_display_setting($setting, $node) {
  global $user;

  if (isset($_GET[$setting])) {
    $value = $_GET[$setting];
  }
  else {
    // get the setting's site default
    switch ($setting) {
    case 'threshold':
      $default = variable_get('comment_default_threshold_'. $node->type, SLASHCOMMENTS_DEFAULT_THRESHOLD);
      break;
    case 'mode':
      $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);
      break;
    case 'sort':
      $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_OLDEST_FIRST);
      break;
    case 'comments_per_page':
      $default = variable_get('comment_default_per_page_'. $node->type, 50);
    }
    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {
      // if comment controls are disabled use site default
      $value = $default;
    }
    else {
      // otherwise use the user's setting if set
      if (isset($user->$setting) && $user->$setting) {
        $value = $user->$setting;
      }
      elseif (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {
        $value = $_SESSION['comment_'. $setting];
      }
      else {
        $value = $default;
      }
    }
  }
  return $value;
}

/**
 * Determine whether a given user can vote on a given comment
 */
function slashcomments_user_can_vote($uid, $cid) {

  if (user_access('administer')) {
    return TRUE;
  }

  // keeps the status for checks which are comment independent
  // to avoid executing them multiple times during comment rendering
  static $can_vote = -1;

  // check user has the needed permission
  if (!(user_access('moderate comments') && user_access('moderate comments'))) {
    return FALSE;
  }

  if ($can_vote == 0) {
    return FALSE;
  }
  if ($can_vote == -1) {
    global $user;

    // check if required days has paased for new users
    if ($uid <> 1 && strtotime("-" . variable_get('slashcomments_limit_newbie', SLASHCOMMENTS_LIMIT_NEWBIE) . " day") < $user->created) {
      $can_vote = 0;
      return FALSE;
    }
    // check if user has the needed karma
    if ($uid <> 1 && variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1
      && slashcomments_get_user_karma($uid) < variable_get('slashcomments_limit_karma', SLASHCOMMENTS_LIMIT_KARMA)) {
        $can_vote = 0;
        return FALSE;
      }
  }
  $can_vote = 1;

  // check if the user has already moderated this comment
  if (votingapi_select_votes(array('content_type' => 'comment', 'content_id' => $cid, 'uid' => $uid))) {
    return FALSE;
  }

  // check if user is participating in the discussion
  $participating = slashcomments_user_participating_in_discussion($uid, $cid);
  return !$participating;
}



/** 
 * Get the template file to use for the author pane
 */
function _slashcomments_get_author_pane_template($used_tpl_file) {

  $tpl_files = array (
    "advf-author-pane"                    => "slashcomments-advf-author-pane-1x",
    "advf-author-pane-stacked"             => "slashcomments-advf-author-pane-stacked-1x",
    "advanced_forum.author-pane"          => "slashcomments-advf-author-pane-2x",
    "advanced_forum.author-pane-stacked"  => "slashcomments-advf-author-pane-stacked-2x",
    "author-pane"                         => "slashcomments-author-pane"
  );

  // Replace the template file with the version provided by slashcomments
  if (module_exists("advanced_forum") && strpos(advanced_forum_get_current_style(), 'stacked')) {
    $used_tpl_file .= "-stacked";
  }
  return $tpl_files[$used_tpl_file];
}


/* Retrieve the right template for author_pane and set it */
function _slashcomments_set_author_pane_template(&$variables) {
  static $new_tpl_file;

  if(empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_author_pane_template($used_tpl_file);
    drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
  }
  $variables['template_files'][] = $new_tpl_file;
}


/**
 * Implementation of hook_preprocess_author_pane().
 */
function slashcomments_preprocess_author_pane(&$variables) {
  _slashcomments_set_author_pane_template($variables);

  // Add karma to template variables
  if (variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1) {
    $variables['slashcomments_karma'] = slashcomments_get_user_karma($variables['account']->uid);
  }
}

/**
 * Check whether user is participating in a given discussion
 */
function slashcomments_user_participating_in_discussion($uid, $cid) {
  // keeps this variable to avoid executing all the checks during
  // multiple comments rendering
  static $participating = -1;

  // result has already been estabilished return it
  if ($participating != -1) {
    return $participating;
  }
  if (variable_get('slashcomments_limit_takepart', SLASHCOMMENTS_LIMIT_TAKEPART) == 1) {
    // get nid of the discussion
    $result = db_query("SELECT n.nid, n.uid FROM {comments} c, {node} n WHERE c.cid=%d AND c.nid = n.nid", $cid);

    $node_info = db_fetch_array($result);
    if ($node_info['uid'] == $uid) {
      return TRUE;
    }

    // get user's comments with nid
    $user_cid = db_result(db_query("SELECT count(*) FROM {comments} WHERE nid=%d AND uid=%d", $node_info['nid'], $uid));
    $participating = ($user_cid == 0) ? 0 : 1;
    return (boolean)$participating;
  }
  else {
    // get nid of the discussion
    $nid = db_result(db_query("SELECT count(*) FROM {comments} WHERE cid=%d AND uid=%d", $cid, $uid));
    return ($nid == 0) ? FALSE : TRUE;
  }
}

/**
 * FAPI definition for the comment moderation form.
 *
 * @ingroup forms
 * @see slashcomments_moderation_form_submit()
 */
function slashcomments_moderation_form($form_state, $cid, $uid) {
  $form['cid'] = array('#type' => 'hidden', '#default_value' => $cid);
  $form['uid'] = array('#type' => 'hidden', '#default_value' => $uid);

  $form['vote'] = array(
    '#title' => '',
    '#type' => 'select',
    '#options' => _slashcomments_moderation_options(),
    '#default_value' => 0,
    '#weight' => 30
  );


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Moderate'),
    '#weight' => 50
  );

  $form['#submit'][] = 'slashcomments_moderation_form_submit';

  return $form;
}

/**
 * Theme the moderation form
 */
function theme_slashcomments_moderation_form($form) {
  $output = '<div class="scomments_container"><div class="container-inline">';
  $output .= '<div class="scomments_form">' . drupal_render($form) . '</div>';
  $output .= '<div class="scomments_loader"></div><div class="scomments_form_status"></div>';
  $output .= '</div></div>';
  return $output;
}

/**
 * Retrieve comment rating
 */
function slashcomments_get_comment_rating($cid) {
  $description = NULL;

  if(_slashcomments_karma_enabled()) {
    $sql = "SELECT r.score+IFNULL(m.modifier,0) score, o.rating
      FROM {slashcomments_contents_rating} r 
      LEFT JOIN {slashcomments_contents_karma} k 
      ON r.content_id = k.content_id
      LEFT JOIN {slashcomments_karma_modifier} m
      ON k.karma >= m.karma_from AND k.karma <= m.karma_to
      INNER JOIN {slashcomments_rating_options} o
      ON r.most_rated_id = o.rating_id
      WHERE r.content_id = %d";
  }
  else {
    $sql = "SELECT r.score, o.rating
      FROM {slashcomments_contents_rating} r, {slashcomments_rating_options} o
      WHERE most_rated_id = o.rating_id and r.content_id = %d";
  }

  $result = db_query($sql, $cid);
  $db_rating = db_fetch_array($result);


  // if not result is retrieved set the default rating and description value
  if ($db_rating) {
    $score = $db_rating->score;
    $rating = $db_rating->rating;
  }
  else {
    $author_id = db_result(db_query("SELECT uid FROM {comment} WHERE cid = %d"), $cid);
    // Decrease the rating by 1 if the comment has been posted by an anonymous user
    $score = ($author_id) ? SLASHCOMMENTS_DEFAULT_RATING : SLASHCOMMENTS_DEFAULT_RATING_ANONYMOUS;
  }

  $score = ($score < -1) ? 1 : (($score > 5) ?  5 : $score);

  // return rating and description
  return array('rating' => $score, 'description' => $rating);
}


/**
 * Update rating for a given commment
 */
function slashcomments_update_rating($content_id) {
  //$row = db_fetch_object($result);
  $rating = slashcomments_calculate_rating($content_id);
  $rating['modified'] = time();

  $exists = db_result(db_query("SELECT count(*) from {slashcomments_contents_rating} WHERE content_id = %d", $content_id));
  if($exists) {
    $update = 'content_id';
  }
  else {
    $update = null;
    $rating['created'] = $rating['modified'];
  }
  $ret = drupal_write_record('slashcomments_contents_rating', $rating, $update);
}

/**
 * Update rating for a given commment
 */
function slashcomments_init_contents_karma($cid, $author_uid = -1) {
  dsm("Staret init contnents");
  if ($author_uid == -1) {
    $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));
  }

  $karma = slashcomments_get_user_karma($author_uid);
  dsm($karma);
  if ($karma == SLASHCOMMENTS_DEFAULT_KARMA) {
    return;
  }

  $record['content_id'] = $cid;
  $record['karma'] = $karma;
  $record['created'] = $record['modified'] = time();
  dsm($record);
  drupal_write_record('slashcomments_contents_karma', $record);
}

function _slashcomments_karma_enabled() {
  return variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1;
}


function _slashcomments_get_user_karma_info($uid) {
  $sql = "SELECT * FROM {slashcomments_users_karma} WHERE uid = %d"; 
  return db_fetch_array(db_query($sql));
}

function _slashcomments_get_content_karma_modifier($content_id) {
  $sql = "SELECT km.modifier 
    FROM {slashcomments_contents_karma} ck, {slashcomments_karma_modifier} km
    WHERE ck.karma BETWEEN km.karma_from AND km.karma_to
    AND content_id=%d";

  $modifier = db_result(db_query($sql, $content_id));
  return ($modifier) ? $modifier : 0;
}

/**
 * Implementation of hook_voting_api_result_alter().
 */
function slashcomments_calculate_rating($cid) {
  $rating = array();

  $sql = "
    SELECT  v.content_id, c.uid,  
    SUM(o.score)  + CASE WHEN c.uid = 0 THEN %d ELSE %d  END score,
    count(*) num_ratings
    FROM {votingapi_vote} v, {slashcomments_rating_options} o,
    (SELECT uid FROM {comments} WHERE cid = %d) c
    WHERE v.content_type = 'comment' AND v.tag = 'slashcomments'
    AND v.value = o.rating_id AND v.content_id = %d
    GROUP BY v.content_id, c.uid
    ";

  $result = db_queryd($sql, SLASHCOMMENTS_DEFAULT_RATING_ANONYMOUS, SLASHCOMMENTS_DEFAULT_RATING, $cid, $cid);
  $rating = db_fetch_array($result);

  dsm($rating);
  /* apply karma modifier if karma is enable */
  if (_slashcomments_karma_enabled()) {
    $rating['score'] += _slashcomments_get_content_karma_modifier($cid);
  }

  /* extrat most voted rating including only positive/negative 
   * depending on the score */
  $rating['most_rated_id'] = '';
  $score_filter = $rating['score'] > 1 ? ">= 0" : "< 0";

  $sql = "SELECT o.rating_id, count(*), max(v.timestamp)
    FROM {votingapi_vote} v, {slashcomments_rating_options} o
    WHERE v.value = o.rating_id
    AND v.content_type = 'comment' AND v.content_id = %d
    AND v.value_type = 'option' AND v.tag = 'slashcomments'
    AND o.score %s
    GROUP BY o.rating_id
    ORDER BY 2 DESC, 3 DESC, 1";

  $row = db_fetch_object(db_query_range($sql, $cid, $score_filter, 0, 1));

  $rating['most_rated_id'] = $row->rating_id;
  dsm($rating);
  return $rating;
}

function slashcomments_update_karma($uid) {
  if ($uid == 0) {
    return;
  }

  // min and max rating considering when karma is calculated
  $comments_num = db_result(db_query("SELECT count(*) FROM {slashcomments_contents_rating} WHERE uid = %d", $uid));
  $comments_for_karma = variable_get('slashcomments_ratings_for_karma', SLASHCOMMENTS_RATINGS_FOR_KARMA);

  $has_karma = slashcomments_user_has_karma($uid);
  dsm("cn: " . $comments_num . "ck: " . $comments_for_karma);
  if ($comments_num < $comments_for_karma) {
    if ($has_karma) {
      db_query("DELETE FROM {slashcomments_users_karma} WHERE uid = %d", $uid);
    }
    return;
  }

  $sql =  "SELECT AVG(CASE WHEN score <  -3 THEN -3
    WHEN score > 5 THEN 5
    ELSE score END ) karma,
      SUM(CASE WHEN score < 1 THEN 1 ELSE 0 END) negative,
      SUM(CASE WHEN score > 1 THEN 1 ELSE 0 END) positive
      FROM {slashcomments_contents_rating} r
      WHERE r.uid = %d
      HAVING count(*) >= " . $comments_for_karma;

  $result = db_query($sql, $uid);
  $record = db_fetch_object($result);
  $record->uid = $uid;
  $record->total = $comments_num;
  $record->neutral = $record->total - $record->positive - $record->negative;
  $record->modified = time();
  if($has_karma) {
    $update = 'uid';
  }
  else {
    $update = null;
    $record->created = $record->modified;
  }

  drupal_write_record('slashcomments_users_karma', $record, $update);
}


function slashcomments_user_has_karma($uid) {
  $sql =  "SELECT count(*)
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $has_karma = db_result(db_query($sql, $uid));

  return ($has_karma) ? TRUE : FALSE;
}

function slashcomments_get_karma_modifier($karma) {
  $sql = "SELECT modifier FROM {slaschomments_karma_modifier} 
    WHERE " . $karma . " BETWEEN karma_from and karma_to"; 

  $modifier = db_result(db_query($sql));

  return ($modifier) ? $modifier : 0;
}

function slashcomments_get_user_karma($uid) {
  //return null;
  $sql =  "SELECT karma
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $karma = db_result(db_query($sql, $uid));

  if ($karma === FALSE OR $karma === null) {
    return SLASHCOMMENTS_DEFAULT_KARMA;
  }
  return $karma;
}

function slashcomments_get_user_karma_stats($uid) {
  //return null;
  $sql =  "SELECT *
    FROM {slashcomments_karma}
    WHERE uid = %d";

  $result = db_query($sql, $uid);
  if ($result === FALSE) {
    return FALSE;
  }
  return db_fetch_array($result);
}

/**
 * Implementation of hook_user().
 *
 */
function slashcomments_user($op, &$edit, &$account, $category = 'account') {
  switch ($op) {
  case 'view':
    if (variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 0) {
      break;
    }

    $user_karma = slashcomments_get_user_karma($account->uid);

    $account->content['slashcomments_karma'] = array(
      '#type' => 'user_profile_category',
      '#title' => t('Karma'),
      '#weight' => 10,
    );
    $account->content['slashcomments_karma']['karma'] = array(
      '#title' => t('Current value '),
      '#type' => 'user_profile_item',
      '#value' => $user_karma,
      '#weight' => 1,
    );
    break;
  }
}



function slashcomments_delete_user_comment_moderation($nid, $uid) {

  $select_votes = "SELECT v.vote_id, c.cid, c.uid
    FROM {comments} c, {votingapi_vote} v
    WHERE c.cid = v.content_id
    AND c.nid = %d AND c.uid <> %d
    AND v.uid = %d and tag = 'slashcomments'
    ORDER BY c.uid";

  $votes = db_query($select_votes, $nid, $uid, $uid);

  $authors = array();
  $votes_id = array();
  $cids = array();
  while ($vote = db_fetch_object($votes)) {
    $votes_id[] = array('vote_id' => $vote->vote_id);
    $cids[] = $vote->cid;
    $authors[$vote->uid] = $vote->uid;
  }

  $votes = db_query($select_votes, $nid, $uid, $uid);

  votingapi_delete_votes($votes_id);

  while ($vote = db_fetch_object($votes)) {
    votingapi_recalculate_results('comment', $vote->cid, TRUE);
    slashcomments_update_rating($vote->cid);
  }

  if (variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1) {
    foreach ($authors as $author) {
      slashcomments_update_karma($author);
    }
  }
}

/**
 * Get available ratings
 */
function _slashcomments_moderation_options() {
  static $rating_options;

  if(!$rating_options) {
    /* extract enabled ratings from the db */
    $sql = "SELECT rating_id, rating
      FROM {slashcomments_rating_options}
      WHERE enabled = 1
      ORDER BY weight
      ";

    $db_ratings = db_query($sql);

    $rating_options = array();
    while($rating = db_fetch_object($db_ratings)) {
      $rating_options[$rating->rating_id] = $rating->rating;
    }
  }

  return $rating_options;
}

function _slashcomments_thresholds($node = NULL) {
  // TODO: display number of comments per each threshold

  // Possible threshold value
  $thresholds = array(-1, 1, 2, 3 , 4, 5);
  $options = array();

  if (!$node) {
    // if node isn't passed to the function we're in the seetings panel
    // for the content type no need to calculate the number of comments
    foreach ($thresholds as $i) {
      $options[$i] = t('Threshold: !n', array('!n' => sprintf("%+d", $i)));
    }
  }
  else {
    $comments_per_rating = array();
    foreach ($thresholds as $i) {
      $comments_per_rating[$i] = 0;
    }

    $rating_field = 'score';
    if (variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1) {
      $rating_field = 'score_karma';
    }

    // get all comments for this node with corresponding rating
    $sql = "SELECT CASE WHEN r.cid is NULL AND c.uid = 0 THEN -1 ELSE 0 END
      + CASE WHEN " . $rating_field ." is null THEN 1 ELSE " . $rating_field . " END rating, count(*) num
      FROM  {comments} c LEFT JOIN {slashcomments_ratings} r
      ON c.cid = r.cid
      WHERE c.nid = %d
      GROUP BY CASE WHEN c.uid = 0 THEN -1 ELSE 0 END + CASE WHEN " . $rating_field ." is null THEN 1 ELSE " . $rating_field . " END";

    $result = db_query($sql, $node->nid);

    while ($data = db_fetch_object($result)) {
      $comments_per_rating[$data->rating] = $data->num;
    }
    $comments_per_rating[-1] = $node->comment_count;

    for ($i = 6; $i>0; $i--) {
      $comments_per_rating[$i - 1] = $comments_per_rating[$i - 1] + $comments_per_rating[$i];
    }
    foreach ($thresholds as $i) {
      $options[$i] = t('!n: !s comments', array('!n' => sprintf("%+d", $i), '!s' => $comments_per_rating[$i]));
    }
  }
  return $options;
}

function _slashcomments_modes() {
  return array(
    SLASHCOMMENTS_MODE_FLAT => t('Display: flat'),
    SLASHCOMMENTS_MODE_THREADED => t('Display: threaded'),
  );
}

function _slashcomments_per_page() {
  $per_page = array(10, 30, 50, 70, 90, 150, 200, 250, 300, 1000);
  $options = array();
  foreach ($per_page as $i) {
    $options[$i] = t('!a per page', array('!a' => $i));
  }
  return $options;
}
