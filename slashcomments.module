<?php
/**
 * @file
 * Module to implement some of the features of slasdhot moderation system
 */

// Commnet flat and trheaded display
define('SLASHCOMMENTS_MODE_FLAT', 2);
define('SLASHCOMMENTS_MODE_THREADED', 4);

// Comment default rating  */
define('SLASHCOMMENTS_DEFAULT_SCORE', 1);
define('SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS', 0);

// Comment default rating  */
define('SLASHCOMMENTS_DEFAULT_THRESHOLD', 2);

// Default Settings Values:
//  limit moderation from participating users
define('SLASHCOMMENTS_LIMIT_TAKEPART', 1);
// days before newbie users can post
define('SLASHCOMMENTS_LIMIT_NEWBIE', 14);
// enable karma
define('SLASHCOMMENTS_ENABLE_KARMA', 0);
// limit moderation based on karma value
define('SLASHCOMMENTS_LIMIT_KARMA', -2);
// initial karma value
define('SLASHCOMMENTS_DEFAULT_KARMA', 1);
// numbers of moderated comment for having karma
define('SLASHCOMMENTS_RATINGS_FOR_KARMA', 10);
// numbers of moderation per day
define('SLASHCOMMENTS_MOD_PER_DAY',10);

define('SLASHCOMMENTS_HELP_PAGE_PATH','slashcomments/help');

/**
 * Implementation of hook_views_api().
 */
function slashcomments_views_api() {
  return array('api' => 2.0,
               'path' => drupal_get_path('module', 'slashcomments') . '/includes/views');
}

/**
 * Implementation of hook_perm().
 */
function slashcomments_perm() {
  return array('moderate comments','administer slashcomments','bypass moderation restriction');
}

/**
 * Implementation of hook_menu().
 */
function slashcomments_menu() {
  $items = array();

  // Add the callback for AJAX moderation
  $items['slashdot/moderate'] = array(
    'title' => 'Slashcomments - AJAX moderation',
    'page callback' => 'slashdotcomments_moderate',
    'access callback' => 'slashcomments_moderate_access',
    'type' => MENU_CALLBACK,
  );

  // Add the callback for the settings page
  $items['admin/settings/slashcomments'] = array(
          'title' => 'Slashcomments',
          'description' => 'Configure slashcomments',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('slashcomments_admin_general_form'),
          'access arguments' => array('administer slashcomments'),
          'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
          'file' => 'slashcomments.admin.inc',
        );

  // Add the Genral Tab to the settings page
  $items['admin/settings/slashcomments/general'] = array(
    'title' => 'General',
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
          'access arguments' => array('administer slashcomments'),
  );

  // Add the karma tab to the settings page
  $items['admin/settings/slashcomments/karma'] = array(
    'title' => 'Karma',
    'weight' => 1,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_karma_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the ratings tab to the settings page
  $items['admin/settings/slashcomments/ratings'] = array(
    'title' => 'Ratings',
    'weight' => 2,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_ratings_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the mantain tab to the settings page
  $items['admin/settings/slashcomments/mantain'] = array(
    'title' => 'Maintanance',
    'weight' => 3,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_mantain_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the callback to the public help page
  $items['slashcomments/help'] = array(
    'title' => 'Slashcomments Help Page',
    //'page callback' => 'slashcomments_help_page',
    'page callback' => 'theme',
    'page arguments' => array('slashcomments_help'),
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments_help.inc',
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function slashcomments_theme() {
  $items['slashcomments_comment'] = array(
    'template' => 'slashcomments-comment',
  );

  $items['slashcomments_help'] = array(
    'template' => 'slashcomments-help',
    'path' => drupal_get_path('module', 'slashcomments') . '/templates',
  );

  $items['slashcomments_moderation_form'] = array(
    'arguments' => array('form' => NULL),
  );

  $items['slashcomments_admin_ratings_form'] = array(
    'arguments' => array('form' => NULL),
  );

  $items['slashcomments_rating'] = array(
    'arguments' => array('rating' => NULL),
  );

  $items['slashcomments_status'] = array(
    'arguments' => array('status_code' => NULL),
  );

  return $items;
}

/**
 * Implementation of access callback used to restrict moderation
 */
function slashcomments_moderate_access() {
  return user_access('access content') && 
    (user_access('moderate comments') || user_access('bypass moderation restriction'));
}

/**
 * Implemente the callback for slashdot/moderate menu entry responsible
 * of hnandling AJAX modration
 */
function slashdotcomments_moderate() {
  global $user;

  // Check needed variable has been sent
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])
    || !is_numeric($_POST['uid']) || !is_numeric($_POST['vote']) ) {
      return;
    }
  
  // save the vote
  if (!slashcomments_store_vote($_POST['cid'], $_POST['vote'])) {
    return;
  }

  // Get the new rating for the moderated comment
  $rating = slashcomments_get_comment_rating($_POST['cid']);

  // Create the string representation of the rating
  $rating_str = theme('slashcomments_rating',$rating);
  
  // Set variable to be used by ajax success hander
  drupal_json(array(
    'status' => 'OK',
    'rating' => $rating_str,
    'message' => t('Comment moderated!'),
    'hide_forms' => !_slashcomments_user_has_mod_points()
  ));
  exit();
}

/**
 * Submit function for comment moderation form, called if AJAX moderation is off
 */
function slashcomments_moderation_form_submit($form, &$form_state) {
  slashcomments_store_vote($form_state['values']['cid'], $form_state['values']['vote']);
}

/**
 * Store a moderation vote
 */
function slashcomments_store_vote($cid, $vote) {
  global $user;
  $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));

  // Check if user is allowed to vote
  if (slashcomments_user_can_vote($user->uid, $cid) <= 0) {
    return FALSE;
  }

  // Build vote object
  $vote  = array(
    'content_type'    => 'comment',
    'content_id'      => $cid,
    'value_type'      => 'option',
    'value'           => $vote,
    'tag'             => 'slashcomments',
  );

  // Cast the vote and recalculate score and rating for the comment
  votingapi_add_votes($vote);
  votingapi_recalculate_results('comment', $cid, TRUE);

  // update rating for the comment and subtract mod points to the moderator
  slashcomments_update_rating($cid);
  slashcomments_use_mod_point($user->uid);

  // If karma is enabled updated its value
  if (_slashcomments_karma_enabled()) {
    slashcomments_update_karma($author_uid);
  }

  return TRUE;
}

/* Theming function for slashcomments_rating. Used to display
 * the score and rating of each comment */
function theme_slashcomments_rating($rating) {
  $icon_url = _slashcomments_get_image_url() . '/question_mark.png';
  $icon_url_2 = _slashcomments_get_image_url() . '/forbidden.png';
  $help_page = url(_slashcomments_get_help_page_path());

  $output = '<span class="scomments_rating">';
  $output .= '(' . t('Score') . ': ' . $rating['score'];
  $output .= ($rating['rating']) ? ' '.$rating['rating'] : '';
  $output .= '<a alt="What is this?" title="What is this?" href="' . $help_page . '"><img class="help_icon" src="'. $icon_url .'" /></a>';
  //$output .= '<a alt="What is this?" title="What is this?" href="' . $help_page . '"><img class="help_icon" src="'. $icon_url_2 .'" /></a>';
  $output .= ')';
  $output .= '</span>';

  return $output;
}

function theme_slashcomments_status($status_code) {
  $status = _slashcomments_get_moderation_prmission_message($status_code);

  $output = '<div class="description">' . $status . '</div>';
  return $output;
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function slashcomments_theme_registry_alter($theme_registry) {
  // replace the theme function for comment_view */
  if (!empty($theme_registry['comment_view'])) {
    $theme_registry['comment_view']['function'] = 'slashcomments_comment_view';
  }

  // replace the theme function for collapsed view with expanded view */
  if (!empty($theme_registry['comment_flat_collapsed'])) {
    $theme_registry['comment_flat_collapsed']['function'] = 'theme_comment_flat_expanded';
  }
  if (!empty($theme_registry['comment_thread_collapsed'])) {
    $theme_registry['comment_thread_collapsed']['function'] = 'theme_comment_thread_expanded';
  }

  // Code ported from the advanced forum module
  // --- The following section manipulates the theme registry so the .tpl files
  // --- for the given templates can be found first in the (sub)theme directory
  // --- then in ancestor themes, if any, and finally in the slashcomments folder.

  // Affected templates
  $templates = array('comment', 'author_pane');

  // Find all our ancestor themes and put them in an array.
  global $theme;
  $themes = list_themes();

  $ancestor_paths = array();
  $ancestor = $theme;
  while ($ancestor && isset($themes[$ancestor]->base_theme)) {
    array_unshift($ancestor_paths, dirname($themes[$themes[$ancestor]->base_theme]->filename));
    $ancestor = $themes[$ancestor]->base_theme;
  }
  $module_path = drupal_get_path('module', 'slashcomments') . '/templates';

  foreach ($templates as $template) {
    // Sanity check in case the template is not being used.
    if (is_array($theme_registry[$template])) {
      // If there was a path in there, store it.
      $existing_path = array_shift($theme_registry[$template]['theme paths']);
      array_unshift($theme_registry[$template]['theme paths'], $existing_path, $module_path);

      // If there are any ancestor paths (ie: we are in a subtheme, add those)
      foreach ($ancestor_paths as $ancestor_path) {
        $theme_registry[$template]['theme paths'][] = $ancestor_path;
      }
      //Put the active theme's path last since that takes precidence.
      $theme_registry[$template]['theme paths'][] = path_to_theme();
    }
  }
}


/** 
 * Get the template file to use for comments
 */
function _slashcomments_get_comment_template($used_tpl_file) {

  $tpl_files = array (
    "advf-forum-post"       => "slashcomments-advf-post-1x",
    "advanced_forum.post"   => "slashcomments-advf-post-2x"
  );

  return ($tpl_files[$used_tpl_file]) ? $tpl_files[$used_tpl_file] : "slashcomments-comment";
}


/* Retrieve the right template for comments and set it */
function _slashcomments_set_comment_template(&$variables) {
  static $new_tpl_file;

  if(empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_comment_template($used_tpl_file);
    _slashcomments_add_comment_template_files($new_tpl_file);
  }
  $variables['template_files'][] = $new_tpl_file;

}

/* Include javascript and stylesheets needed by slashcomments */
function _slashcomments_add_comment_template_files($new_tpl_file) {

  // add base url and other needed js variables
  drupal_add_js(
    array(
      'baseUrl'  => $GLOBALS['base_url'],
      'slashdot' => array('error_status' => t("Error moderationg comment"),
      'load_image_path' => _slashcomments_get_image_url() . '/loading.gif')
    ),
    'setting'
  );

  drupal_add_js(drupal_get_path('module', 'slashcomments') .'/scripts/slashcomments.js');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/slashcomments.css');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
}

/**
 * Preprocesses template variables for the comment template.
 */
function slashcomments_preprocess_comment(&$variables) {
  global $user;

  $comment = $variables['comment'];
  if(!$comment->cid) {
      return;
  }

  _slashcomments_set_comment_template($variables);
  // get score and rating
  $rating = slashcomments_get_comment_rating($comment->cid);

  $variables['slashcomments_rating'] = theme('slashcomments_rating',$rating);

  $reply = arg(0) == 'comment' && (arg(1) == 'reply' || arg(1) == 'edit');
  $can_vote = slashcomments_user_can_vote($user->uid, $comment->cid);
  // Hide moderation module if user can't moderate or is on the edit or reply page
  if (!$reply && $can_vote == 1) {
    $variables['slashcomments_form'] = drupal_get_form('slashcomments_moderation_form', $comment->cid, $comment->uid);
  }
  $variables['slashcomments_Status'] = theme("slashcomments_status", $can_vote);

  // get default threshold for the content type
  $threshold = _slashcomments_get_display_setting('threshold', $variables['node']);

  // fill out template variables
  if ($rating['score'] >= $threshold) {
    $variables['collapsed'] = '';
    $variables['toggle_label'] = 'non_toggle_label';
    $variables['toggle_area'] = 'non_toggle_area';
  }
  else {
    $variables['collapsed'] = 'collapsed';
    $variables['toggle_label'] = 'toggle_label';
    $variables['toggle_area'] = 'toggle_area';
  }
  $variables['toggle_label'] .= ' ' . $comment->own;
  $variables['toggle_area'] .= ' ' . $comment->own;

  // generate permalink
  $page_number = $_GET['page'];

  if (!$page_number) {
    $page_number = 0;
  }

  $fragment = 'comment-' . $variables['comment']->cid;
  $query = ($page_number) ? 'page=' . $page_number : NULL;
  $img_path = drupal_get_path('module', 'slashcomments') . '/images';
  $linktext = '<img src="' . url($img_path) . '/permalink.gif" />';
  $linkpath = 'node/' . $variables['node']->nid;
  $variables['comment_link'] = l($linktext, $linkpath, array('query' => $query, 'fragment' => $fragment, 'html' => TRUE));

  // Link to page created by Comment Page module, if it exists
  $variables['page_link'] = '';
  if (!empty($variables['comment']->page_url) && !(arg(0) == 'comment' && arg(1) == $variables['comment']->cid)) {
    $variables['page_link'] = l(t('(permalink)'), $variables['comment']->page_url);
  }
}

/**
 * Provides implementation for theme_comment_view() override
 */
function slashcomments_comment_view($comment, $node, $links = array(), $visible = TRUE) {
  static $first_new = TRUE;
  $output = '';
  $comment->new = node_mark($comment->nid, $comment->timestamp);
  if ($first_new && $comment->new != MARK_READ) {
    // Assign the anchor only for the first new comment. This avoids duplicate
    // id attributes on a page.
    $first_new = FALSE;
    $output .= "<a id=\"new\"></a>\n";
  }

  //$output .= "<a id=\"comment-$comment->cid\"></a>\n";
  $comment->comment = check_markup($comment->comment, $comment->format, FALSE);

  // Comment API hook
  comment_invoke_comment($comment, 'view');
  $output .= theme('comment', $comment, $node, $links);
  return $output;
}

/**
 * Implementation of hook_comment().
 */
function slashcomments_comment($comment, $op) {
  switch ($op) {
  case 'view':
    global $user;

    // marke comments of the user in order to theme them differently
    if ($user->uid == $comment->uid && $user->uid != 0) {
      $comment->own = "own";
    }
    break;
  case 'insert':
    // if karma is enable apply a modifier to the initial comment rating
    if (_slashcomments_karma_enabled()) {
      slashcomments_init_contents_karma($comment['cid'], $comment['uid']);
    }

    break;
    // If the comment has been removed, delete infos about
    // is score and rating and update author karma
  case 'delete':
    slashcomments_delete_rating($comment->cid);
    break;
  }
}

/**
 * Delete ratings for a single comment
 */
function slashcomments_delete_rating($cid) {
  $delete_votes = "DELETE FROM {votingapi_vote}
    WHERE content_id = %d
    AND tag = 'slashcomments'";

  db_query($delete_votes, $cid);

  if (db_affected_rows() < 1) {
    return;
  }

  $author_uid = db_result(db_query("SELECT uid FROM {slashcomments_contents_rating} WHERE content_id = %d",$cid));
  votingapi_recalculate_results('comment', $cid, TRUE);
  db_query("DELETE FROM {slashcomments_contents_rating} WHERE content_id = %d", $cid);
  db_query("DELETE FROM {slashcomments_contents_karma} WHERE content_id = %d", $cid);

  slashcomments_update_karma($author_uid);
}

/**
 * Add threshold to comments control forms
 */
function slashcomments_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form') {
    unset($form['comment_filter']['comment']['#title']);
  }

  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $form['comment']['comment_default_threshold'] = array(
      '#type' => 'select',
      '#title' => t('Default comments threshold'),
      '#default_value' => variable_get('comment_default_threshold_'. $form['#node_type']->type, SLASHCOMMENTS_DEFAULT_THRESHOLD),
      '#options' => _slashcomments_thresholds(),
      '#description' => t('Default threshold for comments. Comments with lower score will be collapsed.'),
      '#weight' => -5,
    );
    $form['comment']['comment_default_mode'] = array(
      '#type' => 'select',
      '#title' => t('Default display mode'),
      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, SLASHCOMMENTS_MODE_FLAT),
      '#options' => _slashcomments_modes(),
      '#description' => t('The default view for comments.'),
      '#weight' => -4,
    );
    $form['comment']['comment_default_per_page']['#weight'] = -3;
    //order is always oldest first
    unset($form['comment']['comment_default_order']);
  }
  if ($form_id == 'comment_controls') {
    // WARNING: we cannot get node type from form info, so, we have to load from arg(1)
    $node = node_load(arg(1));

    $form['threshold'] = array(
      '#type' => 'select',
      '#title' => t('Threshold'),
      '#options' => _slashcomments_thresholds($node),
      '#default_value' => _slashcomments_get_display_setting('threshold', $node),
      '#weight' => 0,
    );

    $form['mode'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('mode', $node),
      '#options' => _slashcomments_modes(),
      '#weight' => 1,
    );

    //order is always oldest first
    $form['order'] = array(
      '#type' => 'hidden',
      '#value' => COMMENT_ORDER_OLDEST_FIRST,
    );

    $form['comments_per_page'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('comments_per_page', $node),
      '#options' => _slashcomments_per_page(),
      '#weight' => 3,
    );

    $form['#submit'][] = 'slashcomments_comment_control_submit';
  }
}

/**
 * Submit function for comment control form
 */
function slashcomments_comment_control_submit($form, &$form_state) {
  global $user;
  $threshold = $form_state['values']['threshold'];
  $mode = $form_state['values']['mode'];
  $order = $form_state['values']['order'];
  $comments_per_page = $form_state['values']['comments_per_page'];

  if ($user->uid) {
    $account = user_save($user, array('threshold' => $threshold, 'mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }
  }

  $_SESSION['comment_threshold'] = $threshold;
  $_SESSION['comment_mode'] = $mode;
  $_SESSION['comment_sort'] = $order;
  $_SESSION['comment_comments_per_page'] = $comments_per_page;
}


/**
 * Determine whether a given user can vote on a given comment
 */
function slashcomments_user_can_vote($uid, $cid) {

  /* skip controls for the super user */
  if (user_access('bypass moderation restriction') || $uid == 1) {
    return 1;
  }

  // keeps the status for checks which are comment independent
  // to avoid executing them multiple times during comment rendering
  static $can_vote = 99;

  if ($can_vote <= 0) {
    return $can_vote;
  }
  else if ($can_vote == 99) {
    global $user;

    // check user has the needed permissiCon
    if (!user_access('moderate comments')) {
      $can_vote = 0;
    }
    elseif (strtotime("-" . _slashcomments_get_limit_newbie() . " day") < $user->created) {
      $can_vote = 0;
    }
    elseif (_slashcomments_karma_enabled()
      && slashcomments_get_user_karma($uid) < _slashcomments_get_limit_karma()) 
    {
      $can_vote = -2;
    }
    elseif (_slashcomments_get_mod_per_day() > 0 && !_slashcomments_user_has_mod_points($uid)) {
      $can_vote = -3;
    }
    else {
      /* check if the moderator is the author of the node  */
      $node_author = db_result(db_query("SELECT n.uid FROM {comments} c, {node} n WHERE c.cid=%d AND c.nid = n.nid", $cid));

      if ($node_author == $uid) {
        $can_vote = -4;
      }
    }
  }
  if($can_vote <= 0) return $can_vote;
  $can_vote = 1;

  // check if the user has already moderated this comment
  if (votingapi_select_votes(array('content_type' => 'comment', 'content_id' => $cid, 'uid' => $uid, 'tag' => 'slashcomments'))) {
    return -6;
  }


  // check if user is participating in the discussion
  $participating = slashcomments_user_participating_in_discussion($uid, $cid);
  return ($participating) ? $participating : 1;
}

function _slashcomments_get_moderation_prmission_message($code) {
  $message = array(
    -1 => "You don't have permission to moderate this comment",
    -2 => "You need a karma to moderate this comment",
    -3 => "You don't have any moderation point. Wait for" . "to get more",
    -4 => "You can't moderate comments on your own contents",
    -5 => "Being a new user you have to wait" .  "before you can moderate",
    -6 => "You have already moderated this comment as ",
    -7 => "You can't moderate comments on contents you commented",
    -8 => "You can't moderate your own comment"
  );

  return $message[$code];
}

/**
 * Check whether user is participating in a given discussion
 */
function slashcomments_user_participating_in_discussion($uid, $cid) {
  // keeps this variable to avoid executing all the checks during
  // multiple comments rendering
  static $participating = -1;

  // result has already been estabilished return it
  if ($participating != -1) {
    return $participating;
  }
  if (_slashcomments_get_limit_takepart()) {
    $sql = "SELECT count(*) cnt FROM {comments} c WHERE uid = %d AND nid  
      = (SELECT t.nid FROM {comments} t WHERE t.cid = %d)";

    // get user's comments with nid
    $user_cid = db_result(db_query($sql, $uid, $cid));
    $participating = ($user_cid == 0) ? 0 : -7;
    return $participating;
  }
  else {
    // get nid of the discussion
    $nid = db_result(db_query("SELECT count(*) FROM {comments} WHERE cid=%d AND uid=%d", $cid, $uid));
    return ($nid == 0) ? 0 : -8;
  }
}

/** 
 * Get the template file to use for the author pane
 */
function _slashcomments_get_author_pane_template($used_tpl_file) {

  $tpl_files = array (
    "advf-author-pane"                    => "slashcomments-advf-author-pane-1x",
    "advf-author-pane-stacked"             => "slashcomments-advf-author-pane-stacked-1x",
    "advanced_forum.author-pane"          => "slashcomments-advf-author-pane-2x",
    "advanced_forum.author-pane-stacked"  => "slashcomments-advf-author-pane-stacked-2x",
    "author-pane"                         => "slashcomments-author-pane"
  );

  // Replace the template file with the version provided by slashcomments
  if (module_exists("advanced_forum") && strpos(advanced_forum_get_current_style(), 'stacked')) {
    $used_tpl_file .= "-stacked";
  }
  return $tpl_files[$used_tpl_file];
}

/* Retrieve the right template for author_pane and set it */
function _slashcomments_set_author_pane_template(&$variables) {
  static $new_tpl_file;

  if(empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_author_pane_template($used_tpl_file);
    drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
  }
  $variables['template_files'][] = $new_tpl_file;
}

/**
 * Implementation of hook_preprocess_author_pane().
 */
function slashcomments_preprocess_author_pane(&$variables) {
  _slashcomments_set_author_pane_template($variables);

  // Add karma to template variables
  if (_slashcomments_karma_enabled()) {
    $variables['slashcomments_karma'] = slashcomments_get_user_karma($variables['account']->uid);
  }
}

/**
 * FAPI definition for the comment moderation form.
 *
 * @ingroup forms
 * @see slashcomments_moderation_form_submit()
 */
function slashcomments_moderation_form($form_state, $cid, $uid) {
  $form['cid'] = array('#type' => 'hidden', '#default_value' => $cid);
  $form['uid'] = array('#type' => 'hidden', '#default_value' => $uid);

  $form['vote'] = array(
    '#title' => '',
    '#type' => 'select',
    '#options' => _slashcomments_moderation_options(),
    '#default_value' => 0,
    '#weight' => 30
  );


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Moderate'),
    '#weight' => 50
  );

  $form['#submit'][] = 'slashcomments_moderation_form_submit';

  return $form;
}



/**
 * Theme the moderation form
 */
function theme_slashcomments_moderation_form($form) {
  $output = '<div class="scomments_container"><div class="container-inline">';
  $output .= '<div class="scomments_form">' . drupal_render($form) . '</div>';
  $output .= '<div class="scomments_loader"></div><div class="scomments_form_status"></div>';
  $output .= '</div></div>';
  return $output;
}

/**
 * Retrieve comment rating
 */
function slashcomments_get_comment_rating($cid) {
  $score = _slashcomments_get_default_score();
  $rating = '';
  $has_rating = FALSE;

  $sql = "SELECT r.score, o.rating
    FROM {slashcomments_contents_rating} r, {slashcomments_rating_options} o
    WHERE most_rated_id = o.rating_id and r.content_id = %d";

  $result = db_query($sql, $cid);
  $db_rating = db_fetch_object($result);

  // if not result is retrieved set the default rating and description value
  if ($db_rating) {
    $score = $db_rating->score;
    $rating = $db_rating->rating;
    $has_rating = TRUE;
  }

  if(_slashcomments_karma_enabled()) {
    $modifier = _slashcomments_get_content_karma_modifier($cid);
    if ($modifier) {
      $score += $modifier;
      $has_rating = TRUE;
    }
  }

  if($has_rating == FALSE) {
    $author_id = db_result(db_query("SELECT uid FROM {comments} WHERE cid = %d", $cid));
    // Decrease the rating by 1 if the comment has been posted by an anonymous user
    $score = ($author_id) ? _slashcomments_get_default_score() : _slashcomments_get_default_score_anonymous();
  }

  $score = ($score < -1) ? -1 : (($score > 5) ?  5 : $score);

  // return rating and description
  return array('score' => $score, 'rating' => $rating);
}

function slashcomments_upodate_all_ratings() {
  $sql = "SELECT DISTINCT cid 
    FROM {votingapi_vote} v
    WHERE v.content_type = 'comment' AND v.tag = 'slashcomments'
    AND v.value = o.rating_id AND v.content_id = %d";

  $result = db_query($sql);

  while($cid = db_fetch_array($result)) {
    slashcomments_update_rating($cid);
  }
}

/**
 * Update rating for a given commment
 */
function slashcomments_update_rating($content_id) {
  //$row = db_fetch_object($result);
  $rating = slashcomments_calculate_rating($content_id);
  $rating['modified'] = time();

  $exists = db_result(db_query("SELECT count(*) from {slashcomments_contents_rating} WHERE content_id = %d", $content_id));
  if($exists) {
    $update = 'content_id';
  }
  else {
    $update = null;
    $rating['created'] = $rating['modified'];
  }
  $ret = drupal_write_record('slashcomments_contents_rating', $rating, $update);
}

/**
 * Update rating for a given commment
 */
function slashcomments_init_contents_karma($cid, $author_uid = -1) {
  if ($author_uid == -1) {
    $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));
  }

  $karma = slashcomments_get_user_karma($author_uid);
  if ($karma == _slashcomments_get_default_karma()) {
    return;
  }

  $record['content_id'] = $cid;
  $record['karma'] = $karma;
  $record['created'] = $record['modified'] = time();
  drupal_write_record('slashcomments_contents_karma', $record);
}

function _slashcomments_karma_enabled() {
  return variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1;
}

function _slashcomments_get_content_karma_modifier($content_id) {
  $sql = "SELECT km.modifier 
    FROM {slashcomments_contents_karma} ck, {slashcomments_karma_modifier} km
    WHERE ck.karma BETWEEN km.karma_from AND km.karma_to
    AND content_id=%d";

  $modifier = db_result(db_query($sql, $content_id));
  return ($modifier) ? $modifier : 0;
}

/**
 * Implementation of hook_voting_api_result_alter().
 */
function slashcomments_calculate_rating($cid) {
  $rating = array();

  $sql = "
    SELECT  v.content_id, c.uid,  
    SUM(o.score)  + CASE WHEN c.uid = 0 THEN %d ELSE %d  END score,
    count(*) num_ratings
    FROM {votingapi_vote} v, {slashcomments_rating_options} o,
    (SELECT uid FROM {comments} WHERE cid = %d) c
    WHERE v.content_type = 'comment' AND v.tag = 'slashcomments'
    AND v.value = o.rating_id AND v.content_id = %d
    GROUP BY v.content_id, c.uid
    ";

  $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(), $cid, $cid);
  $rating = db_fetch_array($result);

  /* extrat most voted rating including only positive/negative 
   * depending on the score */
  $rating['most_rated_id'] = '';
  $score_filter = $rating['score'] >= 1 ? ">= 0" : "< 0";

  $sql = "SELECT o.rating_id, count(*), max(v.timestamp)
    FROM {votingapi_vote} v, {slashcomments_rating_options} o
    WHERE v.value = o.rating_id
    AND v.content_type = 'comment' AND v.content_id = %d
    AND v.value_type = 'option' AND v.tag = 'slashcomments'
    AND o.score %s
    GROUP BY o.rating_id
    ORDER BY 2 DESC, 3 DESC, 1";

  $row = db_fetch_object(db_query_range($sql, $cid, $score_filter, 0, 1));

  $rating['most_rated_id'] = $row->rating_id;
  return $rating;
}

function slashcomments_update_karma($uid) {
  if ($uid == 0) {
    return;
  }

  // min and max rating considering when karma is calculated
  $comments_num = db_result(db_query("SELECT count(*) FROM {slashcomments_contents_rating} WHERE uid = %d", $uid));
  $comments_for_karma = _slashcomments_get_ratings_for_karma();
  $has_karma = slashcomments_user_has_karma($uid);
  if ($comments_num < $comments_for_karma) {
    if ($has_karma) {
      db_query("DELETE FROM {slashcomments_users_karma} WHERE uid = %d", $uid);
    }
    return;
  }

  $sql =  "SELECT AVG(CASE WHEN score <  -3 THEN -3
    WHEN score > 5 THEN 5
    ELSE score END ) karma,
      SUM(CASE WHEN score < 1 THEN 1 ELSE 0 END) negative,
      SUM(CASE WHEN score > 1 THEN 1 ELSE 0 END) positive
      FROM {slashcomments_contents_rating} r
      WHERE r.uid = %d
      HAVING count(*) >= %d";

  $result = db_query($sql, $uid, $comments_for_karma);
  $record = db_fetch_object($result);
  $record->uid = $uid;
  $record->total = $comments_num;
  $record->neutral = $record->total - $record->positive - $record->negative;
  $record->modified = time();
  if($has_karma) {
    $update = 'uid';
  }
  else {
    $update = null;
    $record->created = $record->modified;
  }

  drupal_write_record('slashcomments_users_karma', $record, $update);
}


function slashcomments_user_has_karma($uid) {
  $sql =  "SELECT count(*)
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $has_karma = db_result(db_query($sql, $uid));

  return ($has_karma) ? TRUE : FALSE;
}


function slashcomments_get_user_karma($uid) {
  //return null;
  $sql =  "SELECT karma
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $karma = db_result(db_query($sql, $uid));

  if ($karma === FALSE OR $karma === null) {
    return _slashcomments_get_default_karma();
  }
  return $karma;
}


/**
 * Implementation of hook_user().
 */
function slashcomments_user($op, &$edit, &$account, $category = 'account') {
  switch ($op) {
  case 'view':
    if (!_slashcomments_karma_enabled()) {
      break;
    }

    $user_karma = slashcomments_get_user_karma($account->uid);

    $account->content['slashcomments_karma'] = array(
      '#type' => 'user_profile_category',
      '#title' => t('Karma'),
      '#weight' => 10,
    );
    $account->content['slashcomments_karma']['karma'] = array(
      '#title' => t('Current value '),
      '#type' => 'user_profile_item',
      '#value' => $user_karma,
      '#weight' => 1,
    );
    break;
  }
}

/**
 * Get available ratings
 */
function _slashcomments_moderation_options() {
  static $rating_options;

  if(!$rating_options) {
    /* extract enabled ratings from the db */
    $sql = "SELECT rating_id, rating
      FROM {slashcomments_rating_options}
      WHERE enabled = 1
      ORDER BY weight
      ";

    $db_ratings = db_query($sql);

    $rating_options = array();
    while($rating = db_fetch_object($db_ratings)) {
      $rating_options[$rating->rating_id] = $rating->rating;
    }
  }

  return $rating_options;
}

function _slashcomments_thresholds($node = NULL) {

  // Possible threshold value
  $thresholds = array(-1, 1, 2, 3 , 4, 5);
  $options = array();

  if (!$node) {
    // if node isn't passed to the function we're in the seetings panel
    // for the content type no need to calculate the number of comments
    foreach ($thresholds as $i) {
      $options[$i] = t('Threshold: !n', array('!n' => sprintf("%+d", $i)));
    }
  }
  else {
    $comments_per_rating = array();
    foreach ($thresholds as $i) {
      $comments_per_rating[$i] = 0;
    }

    $rating_field = 'score';
    if (_slashcomments_karma_enabled()) {
      $sql = "
        SELECT score, sum(num) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END)+IFNULL(m.modifier,0) score, 
          count(*) num 
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          LEFT JOIN {slashcomments_contents_karma} k
          ON c.cid = k.content_id
          LEFT JOIN {slashcomments_karma_modifier} m
          ON k.karma >= m.karma_from AND k.karma <= m.karma_to
          WHERE c.nid = %d
          GROUP BY c.uid, IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END)+IFNULL(m.modifier,0)
        ) a
        GROUP BY score";
    }
    else {
      $sql = "SELECT score, sum(num) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END) score, 
          count(*) num 
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          WHERE c.nid = %d
          GROUP BY c.uid, IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END)
        ) a
        GROUP BY score";
    }

    $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(),  $node->nid);

    while ($data = db_fetch_object($result)) {
      $comments_per_rating[$data->score] = $data->num;
    }
    $comments_per_rating[-1] = $node->comment_count;

    for ($i = 6; $i>0; $i--) {
      $comments_per_rating[$i - 1] = $comments_per_rating[$i - 1] + $comments_per_rating[$i];
    }
    foreach ($thresholds as $i) {
      $options[$i] = t('!n: !s comments', array('!n' => sprintf("%+d", $i), '!s' => $comments_per_rating[$i]));
    }
  }
  return $options;
}

function _slashcomments_modes() {
  return array(
    SLASHCOMMENTS_MODE_FLAT => t('Display: flat'),
    SLASHCOMMENTS_MODE_THREADED => t('Display: threaded'),
  );
}

function _slashcomments_per_page() {
  $per_page = array(10, 30, 50, 70, 90, 150, 200, 250, 300, 1000);
  $options = array();
  foreach ($per_page as $i) {
    $options[$i] = t('!a per page', array('!a' => $i));
  }
  return $options;
}

/**
 * Get display settings for a given content
 */
function _slashcomments_get_display_setting($setting, $node) {
  global $user;

  if (isset($_GET[$setting])) {
    $value = $_GET[$setting];
  }
  else {
    // get the setting's site default
    switch ($setting) {
    case 'threshold':
      $default = variable_get('comment_default_threshold_'. $node->type, SLASHCOMMENTS_DEFAULT_THRESHOLD);
      break;
    case 'mode':
      $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);
      break;
    case 'sort':
      $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_OLDEST_FIRST);
      break;
    case 'comments_per_page':
      $default = variable_get('comment_default_per_page_'. $node->type, 50);
    }
    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {
      // if comment controls are disabled use site default
      $value = $default;
    }
    else {
      // otherwise use the user's setting if set
      if (isset($user->$setting) && $user->$setting) {
        $value = $user->$setting;
      }
      elseif (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {
        $value = $_SESSION['comment_'. $setting];
      }
      else {
        $value = $default;
      }
    }
  }
  return $value;
}

/* get values of the limit_newbie settings variable */
function _slashcomments_get_limit_newbie() {
  return variable_get('slashcomments_limit_newbie', SLASHCOMMENTS_LIMIT_NEWBIE);
}

/* get values of the limit_newbie settings variable */
function _slashcomments_get_limit_karma() {
  return variable_get('slashcomments_limit_karma', SLASHCOMMENTS_LIMIT_KARMA);
}

/* get values of the limit_newbie settings variable */
function _slashcomments_get_limit_takepart() {
  return variable_get('slashcomments_limit_takepart', SLASHCOMMENTS_LIMIT_TAKEPART);
}

/* get values of the default_score settings variable */
function _slashcomments_get_default_score() {
  return variable_get('slashcomments_default_score', SLASHCOMMENTS_DEFAULT_SCORE);
}

/* get values of the default_score_anonymous settings variable */
function _slashcomments_get_default_score_anonymous() {
  return variable_get('slashcomments_default_score_anonymous', SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS);
}

/* get values of the default_karma settings variable */
function _slashcomments_get_default_karma() {
  return variable_get('slashcomments_default_karma', SLASHCOMMENTS_DEFAULT_KARMA);
}

/* get values of the rating_for_karma settings variable */
function _slashcomments_get_ratings_for_karma() {
  return variable_get('slashcomments_ratings_for_karma', SLASHCOMMENTS_RATINGS_FOR_KARMA);
}

/* get values of the mod_per_day settings variable */
function _slashcomments_get_mod_per_day() {
  return variable_get('slashcomments_mod_per_day',SLASHCOMMENTS_MOD_PER_DAY);
}

/* get values of the help_page_path settings variable */
function _slashcomments_get_help_page_path() {
  return variable_get('slashcomments_help_page_path',SLASHCOMMENTS_HELP_PAGE_PATH);
}

/* get the url of slashcomments images folder */
function _slashcomments_get_image_url() {
  static $image_url;

  if(!$image_url) {
    $image_url = url(drupal_get_path('module', 'slashcomments') . '/images');
  }
  return $image_url;
}

function slashcomments_get_user_mod_points($uid) {
  $sql = "SELECT uid, points, assigned
    FROM {slashcomments_users_mod_points}
    WHERE uid = %d";


  $data = db_fetch_array(db_query($sql,$uid));

  if(!$data) {
    $points = slashcomments_assign_user_mod_points($uid,1);
  }
  else  if(time() - $data['assigned'] > (60*60*24)) {
    $points =  slashcomments_assign_user_mod_points($uid,0);
  }
  else {
    $points = $data['points'];
  }

  return $points;
}

function slashcomments_assign_user_mod_points($uid, $new = -1) {
  if($new == -1) {
    $new = !db_result(db_query("SELECT count(*) FROM {slashcomments_users_mod_points}"));
  }
  $record['uid'] = $uid;
  $record['points'] = _slashcomments_get_mod_per_day();
  $record['modified'] = $record['assigned'] = time();
  if($new) {
    $record['created'] = $record['modified'];
  } 
  else {
    $update = 'uid';
  }
  drupal_write_record('slashcomments_users_mod_points', $record, $update);
  return slashcomments_get_user_mod_points($uid);
}

function _slashcomments_user_has_mod_points($uid) {
  return (slashcomments_get_user_mod_points($uid) > 0);
}

function slashcomments_use_mod_point($uid) {
  $sql = "UPDATE {slashcomments_users_mod_points} 
    SET points = CASE WHEN points = 0 THEN 0 ELSE points-1 END
    WHERE uid = %d";

  db_query($sql,$uid);
}
