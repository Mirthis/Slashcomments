<?php
/**
 * @file
 * The slashcomments module enanche the default commenting system with some of 
 * the features of the slashdot moderation system (moderation, karma, view by 
 * threshold
 */

// Fixed costants used by the module - settings are not available
// Commnet flat and trheaded display
define('SLASHCOMMENTS_MODE_FLAT', 2);
define('SLASHCOMMENTS_MODE_THREADED', 4);
// Value to represent that a user has infinite moderation points
define('SLASHCOMMENTS_INFINITE_MOD_POINTS', -1);
// Lowest and highest displayed score (not the actual score stored in the db)
define('SLASHCOMMENTS_LOWEST_DISPLAY_RATING',-1);
define('SLASHCOMMENTS_HIGHEST_DISPLAY_RATING',5);

// Module settings - can be configured through the administration page
// Comment default rating
define('SLASHCOMMENTS_DEFAULT_SCORE', 1);
define('SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS', 0);
// Default threshold for displaying comments
define('SLASHCOMMENTS_DEFAULT_THRESHOLD', 2);
//  limit moderation from participating users
define('SLASHCOMMENTS_LIMIT_TAKEPART', 1);
// days before newbie users can post
define('SLASHCOMMENTS_LIMIT_NEWBIE', 14);
// enable karma
define('SLASHCOMMENTS_ENABLE_KARMA', 0);
// limit moderation based on karma value
define('SLASHCOMMENTS_LIMIT_KARMA', 2);
// initial karma value
define('SLASHCOMMENTS_DEFAULT_KARMA', 1);
// numbers of moderated comment for having karma
define('SLASHCOMMENTS_RATINGS_FOR_KARMA', 10);
// numbers of moderation points per day
define('SLASHCOMMENTS_MOD_PER_DAY', 10);
// default path for the help page
define('SLASHCOMMENTS_HELP_PAGE_PATH', 'slashcomments/help');
// Lower score valid for karma
define('SLASHCOMMENTS_LOWEST_SCORE_FOR_KARMA', -6);
// Higher score valid for karma
define('SLASHCOMMENTS_HIGHEST_SCORE_FOR_KARMA', 8);


/**
 * Implementation of hook_views_api().
 */
function slashcomments_views_api() {
  return array('api' => 2.0,
               'path' => drupal_get_path('module', 'slashcomments') . '/includes/views');
}

/**
 * Implementation of hook_menu().
 */
function slashcomments_menu() {
  $items = array();

  // Add the callback for AJAX moderation
  $items['slashcomments/moderate'] = array(
    'title' => 'Slashcomments - AJAX moderation',
    'page callback' => 'slashcomments_moderate',
    'access callback' => 'slashcomments_moderate_access',
    'type' => MENU_CALLBACK,
  );

  // Add the callback for loading comment with AJAX
  $items['slashcomments/load_comment'] = array(
    'title' => 'Slashcomments - AJAX commet loading',
    'page callback' => 'slashcomments_load_comment',
    'access arguments' => array('access comments'),
    'type' => MENU_CALLBACK,
  );

  // Add the callback for the settings page
  $items['admin/settings/slashcomments'] = array(
          'title' => 'Slashcomments',
          'description' => 'Configure slashcomments',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('slashcomments_admin_general_form'),
          'access arguments' => array('administer slashcomments'),
          'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
          'file' => 'slashcomments.admin.inc',
        );

  // Add the Genral Tab to the settings page
  $items['admin/settings/slashcomments/general'] = array(
    'title' => 'General',
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
          'access arguments' => array('administer slashcomments'),
  );

  // Add the Karma tab to the settings page
  $items['admin/settings/slashcomments/karma'] = array(
    'title' => 'Karma',
    'weight' => 1,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_karma_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the Ratings tab to the settings page
  $items['admin/settings/slashcomments/ratings'] = array(
    'title' => 'Ratings',
    'weight' => 2,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_ratings_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the mantain tab to the settings page
  /*$items['admin/settings/slashcomments/mantain'] = array(
    'title' => 'Maintanance',
    'weight' => 3,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_mantain_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );*/

  // Add the callback to the public help page
  $items['slashcomments/help'] = array(
    'title' => 'Slashcomments Help Page',
    //'page callback' => 'slashcomments_help_page',
    'page callback' => 'theme',
    'page arguments' => array('slashcomments_help'),
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments_help.inc',
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function slashcomments_theme() {
  // Theme comments
  $items['slashcomments_comment'] = array(
    'template' => 'slashcomments-comment',
  );

  // Theme the default help page
  $items['slashcomments_help'] = array(
    'template' => 'slashcomments-help',
    'path' => drupal_get_path('module', 'slashcomments') . '/templates',
  );

  // Theme the moderation form wrapper
  $items['slashcomments_form_wrapper'] = array(
    'arguments' => array('cid' => NULL, 'uid' => NULL, 'message' => NULL),
  );

  // Theme the form in the Ratings settings page
  $items['slashcomments_admin_ratings_form'] = array(
    'arguments' => array('form' => NULL),
  );

  // Theme comment rating and score
  $items['slashcomments_rating'] = array(
    'arguments' => array('rating' => NULL),
  );

  // Theme modration result
  $items['slashcomments_moderation_status'] = array(
    'arguments' => array('status_result' => NULL),
  );

  // Theme karma
  $items['slashcomments_karma'] = array(
    'arguments' => array('karma' => NULL),
  );

  return $items;
}


/**
 * Implementation of hook_perm().
 */
function slashcomments_perm() {
  return array('moderate comments', 'administer slashcomments', 'bypass moderation restriction');
}

/**
 * Implements access callback for moderatiing comments
 */
function slashcomments_moderate_access() {
  return user_access('access content') &&
    (user_access('moderate comments') || user_access('bypass moderation restriction'));
}


/**
 * Determines if a given user can vote on a given comment
 *
 * According to user's role permission, karma, and other slashcomments settings 
 * determine if a user should be allowed to moderate a specific comment
 *
 * @param $uid
 *  User id of the user who's going to be checked
 *
 * @parma $cid
 *  Comment id of the comment the user need to moderate
 *
 * @return
 *  An associative array with two keys:
 *  - result: 1 if user can moderate, 0 if user can't moderate
 *  - message: when result is 0 the reason why the user can't moderate
 */
function slashcomments_user_can_moderate($uid, $cid) {
  /* skip controls for the super user */
  if (user_access('bypass moderation restriction') || $uid == 1) {
    return array('result' => 1, 'message' => '');
  }

  // keeps the status for checks which are comment independent
  // to avoid executing them multiple times during comment rendering
  static $result = array('result' => 0, 'message' => '', 'step' => 0);

  // comment indipendent checks has given a negative result, exit
  if ($result['step'] == 1) {
    return $result;
  }
  if ($result['step'] != 2) { // comment's indipendent checks need to be performed
    $can_vote = 0;
    global $user;

    // check user has the needed permissiCon
    if (!user_access('moderate comments')) {
      $result['message'] = _slashcomments_get_moderation_message(-1, $uid);
      return $result;
    }

    // check if user is still a new bie
    if (strtotime("-" . _slashcomments_get_limit_newbie() . " day") < $user->created) {
      $result['message'] = _slashcomments_get_moderation_message(-5, $uid);
      return $result;
    }

    // check if user has the needed karma
    if (_slashcomments_karma_enabled()
      && slashcomments_get_user_karma($uid) < _slashcomments_get_limit_karma()) {
        $result['message'] = _slashcomments_get_moderation_message(-2, $uid);
        return $result;
      }

    // check if the user has enough moderation points
    if (_slashcomments_get_mod_per_day() != SLASHCOMMENTS_INFINITE_MOD_POINTS && !_slashcomments_user_has_mod_points($uid)) {
      $result['message'] = _slashcomments_get_moderation_message(-3, $uid);
      return $result;
    }

    // check if the moderator is the author of the node  */
    $node_author = db_result(db_query("SELECT n.uid FROM {comments} c, {node} n WHERE c.cid=%d AND c.nid = n.nid", $cid));

    if ($node_author == $uid) {
      $result['message'] = _slashcomments_get_moderation_message(-4, $uid);
      return $result;
    }
  }

  $result = array('step' => 2);
  // check if the user has already moderated this comment
  if (votingapi_select_votes(array('content_type' => 'comment', 'content_id' => $cid, 'uid' => $uid, 'tag' => 'slashcomments'))) {
    $result['message'] = _slashcomments_get_moderation_message(-6, $uid);
    return $result;
  }

  // check if user is participating in the discussion
  return slashcomments_user_participating_in_discussion($uid, $cid);
}


/**
 * Checks if user has taken part in the discussion
 *
 * Checks if the user is the author of the comment or if it has already 
 * commented the node
 *
 * @param $uid
 *  User id of the user who's going to be checked
 *
 * @parma $cid
 *  Comment id of the comment the user need to moderate
 *
 * @return
 *  An associative array with two keys:
 *  - result: 1 if user can moderate, 0 if user can't moderate
 *  - message: when result is 0 the reason why the user can't moderate
 */
function slashcomments_user_participating_in_discussion($uid, $cid) {
  // keeps this variable to avoid executing unecessary checks during
  // multiple comments rendering
  static $participating = -1;

  // result has already been estabilished in  a previous execution.
  if ($result) {
    return $result;
  }

  // When the option is set check if the user has already commented the node
  if (_slashcomments_get_limit_takepart()) {
    $sql = "SELECT count(*) cnt FROM {comments} c WHERE uid = %d AND nid
      = (SELECT t.nid FROM {comments} t WHERE t.cid = %d)";

    // get user's comments with nid
    $user_cid = db_result(db_query($sql, $uid, $cid));
    if ($user_cid == 0) {
      $result = array('result' => 1, 'message' => _slashcomments_get_moderation_message(1, $uid));
    }
    else {
      $result = array('result' => 0, 'message' => _slashcomments_get_moderation_message(-7, $uid));
    }
    return $result;
  }
  else {
    // get nid of the discussion
    $nid = db_result(db_query("SELECT count(*) FROM {comments} WHERE cid=%d AND uid=%d", $cid, $uid));
    if ($nid == 0) {
      return array('result' => 1, 'message' => _slashcomments_get_moderation_message(1, $uid));
    }
    return array('result' => 0, 'message' => _slashcomments_get_moderation_message(-8, $uid));
  }
}

/**
 * Loads a single comment
 *
 * This callback is called when a collapsed comment is expanded for the first 
 * time. It loads the comment body and return it to the javascript function to 
 * be displayed
 */
function slashcomments_load_comment() {
  // If expected parameter are not sent in the HTTP request return
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])) {
    return;
  }

  // Force rendering of comment body even if it's score is below theshold
  global $_slashcomments_ignore_threshold;
  $_slashcomments_ignore_threshold = 1;

  // load the parent node of the comment
  $nid = db_result(db_query("SELECT nid FROM {comments} WHERE cid = %d", $_POST['cid']));
  if (!$nid) return;

  $node = node_load($nid);

  // retrieve comment output
  $out = comment_render($node, $_POST['cid']);
  
  // Make the result available for the ajax handler
  drupal_json(array(
    'status' => 'OK',
    'message' => $out,
  ));

  // Restore standard rendering
  $_slashcomments_ignore_threshold = 0;
  exit();
}

/**
 * Moderates a comment.
 *
 * This callback is called through AJAX when the moderate form is submitted. 
 */
function slashcomments_moderate() {
  global $user;

  // If expected parameter are not sent in the HTTP request return
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])
    || !is_numeric($_POST['uid']) || !is_numeric($_POST['vote']) ) {
      return;
    }

  // save the moderation
  $result = slashcomments_store_vote($_POST['cid'], $_POST['vote']);
  if (!$result['result']) {
    drupal_json(array(
      'status' => 'OK',
      'message' => theme('slashcomments_moderation_status', $result),
      'hide_forms' => !_slashcomments_user_has_mod_points($user->uid),
    ));
    exit();
  }

  // Get the new rating for the moderated comment
  $rating = slashcomments_get_content_rating($_POST['cid']);

  // Create the string representation of the rating
  $rating_str = theme('slashcomments_rating', $rating);

  // Create the string for the message to display after moderation
  $message_str = theme('slashcomments_moderation_status', $result);

  // Set variable for the JS handler
  drupal_json(array(
    'status' => 'OK',
    'rating' => $rating_str,
    'message' => $message_str,
    'hide_forms' => !_slashcomments_user_has_mod_points($user->uid)
  ));
  exit();
}

/**
 * Submits comment without using AJAX
 */
function slashcomments_moderation_form_submit($form, &$form_state) {
  slashcomments_store_vote($form_state['values']['cid'], $form_state['values']['vote']);
}

/**
 * Stores a moderation vote
 */
function slashcomments_store_vote($cid, $vote) {
  global $user;

  $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));

  $result = slashcomments_user_can_moderate($user->uid, $cid);

  // Check if user is allowed to vote
  if ($result['result'] == 0) {
    return $result;
  }

  // Build vote object
  $vote  = array(
    'content_type'    => 'comment',
    'content_id'      => $cid,
    'value_type'      => 'option',
    'value'           => $vote,
    'tag'             => 'slashcomments',
  );

  // Cast the vote and recalculate score and rating for the comment
  votingapi_add_votes($vote);
  votingapi_recalculate_results('comment', $cid, TRUE);

  // update rating for the comment and subtract mod points to the moderator
  slashcomments_update_rating($cid);
  slashcomments_use_mod_point($user->uid);

  // If karma is enabled updated its value
  if (_slashcomments_karma_enabled()) {
    slashcomments_update_karma($author_uid);
  }
  $result['message'] = t('Comment moderated!') . ' ';
  $result['message'] .= _slashcomments_get_moderation_message(1, $user->uid);
  return $result;
}


/**
 * Deletes ratings for a single comment,
 *
 * It delets from the database all information slashcomments stored for the 
 * comment. Karma of the author is re-caculated.
 *
 * @param $cid
 *   Comment id of the deleted comment.
 */
function slashcomments_delete_rating($cid) {
  $delete_votes = "DELETE FROM {votingapi_vote}
    WHERE content_id = %d
    AND tag = 'slashcomments'";

  db_query($delete_votes, $cid);

  if (db_affected_rows() < 1) {
    return;
  }

  $author_uid = db_result(db_query("SELECT uid FROM {slashcomments_contents_rating} WHERE content_id = %d", $cid));
  votingapi_recalculate_results('comment', $cid, TRUE);
  db_query("DELETE FROM {slashcomments_contents_rating} WHERE content_id = %d", $cid);
  db_query("DELETE FROM {slashcomments_contents_karma} WHERE content_id = %d", $cid);

  slashcomments_update_karma($author_uid);
}


/**
 * Retrieves content rating.
 *
 * Get comment score and rating for a specific content. Only comments are 
 * currently supported.
 *
 * @param $cid
 *   Comment id of the comments
 *
 * @return
 *   Array containing score and rating
 *   'score' => numeric score associated to the comment
 *   'rating' => text correspoding to the most voted rating
 */
function slashcomments_get_content_rating($cid) {
  $score = _slashcomments_get_default_score();
  $rating = '';
  $has_rating = FALSE;

  $sql = "SELECT r.score, o.rating
    FROM {slashcomments_contents_rating} r, {slashcomments_rating_options} o
    WHERE most_rated_id = o.rating_id and r.content_id = %d";

  // Get score and rating for the comment
  $result = db_query($sql, $cid);
  $db_rating = db_fetch_object($result);

  // if no result is retrieved set the default rating and description value
  if ($db_rating) {
    $score = $db_rating->score;
    $rating = $db_rating->rating;
    $has_rating = TRUE;
  }

  // if karma is enabled get karma modified score
  if (_slashcomments_karma_enabled()) {
    $modifier = _slashcomments_get_content_karma_modifier($cid);
    if ($modifier) {
      $score += $modifier;
      $has_rating = TRUE;
    }
  }

  // If no rating information has been retrieved from the db check if it's 
  // author is anonymous and apply modifier to the default rating if needed
  if ($has_rating == FALSE) {
    $author_id = db_result(db_query("SELECT uid FROM {comments} WHERE cid = %d", $cid));
    $score = ($author_id) ? _slashcomments_get_default_score() : _slashcomments_get_default_score_anonymous();
  }

  // Avoid having an infinite score scale limiting min and max score value
  $score = ($score < SLASHCOMMENTS_LOWEST_DISPLAY_RATING) ? SLASHCOMMENTS_LOWEST_DISPLAY_RATING 
    : (($score > SLASHCOMMENTS_HIGHEST_DISPLAY_RATING) ?  SLASHCOMMENTS_HIGHEST_DISPLAY_RATING : $score);

  // return score and rating
  return array('score' => $score, 'rating' => $rating);
}

/**
 * Updates rating for a given content.
 *
 * Recalculate rating for a given content according to the moderation/votes it 
 * received. Only comments are supported as content.
 *
 * @param $content_id
 *   The content identifier.
 */
function slashcomments_update_rating($content_id) {
  // Get the new rating for the content
  $rating = slashcomments_calculate_rating($content_id);

  // Set missing field base on the fact the content rating has already be stored
  $rating['modified'] = time();

  $exists = db_result(db_query("SELECT count(*) from {slashcomments_contents_rating} WHERE content_id = %d", $content_id));
  if ($exists) {
    $update = 'content_id';
  }
  else {
    $update = NULL;
    $rating['created'] = $rating['modified'];
  }

  // Store the rating in the DB
  $ret = drupal_write_record('slashcomments_contents_rating', $rating, $update);
}

/**
 * Sets the initial rating for a given content.
 *
 * When a content is submitted it's initial score depends on the user karma. If 
 * the score is different from the default score it needs to be stored to be 
 * used lately when the score is retrieved.
 *
 * @param $cid
 *   Content_id for the content the initial value is going to be assigned
 *
 * @param $author_uid
 *   Identifier of the user who posted the content
 */
function slashcomments_init_contents_karma($cid, $author_uid = -1) {
  // If author is not passed to the function retrieve it from the database
  if ($author_uid == -1) {
    $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));
  }

  // If user karma has the default value no modifier is applied
  // @TODO check modifier associated to the karma value and not karma value 
  // itself
  $karma = slashcomments_get_user_karma($author_uid);
  if ($karma == _slashcomments_get_default_karma()) {
    return;
  }

  // Assign values to missing filed and store the info
  $record['content_id'] = $cid;
  $record['karma'] = $karma;
  $record['created'] = $record['modified'] = time();
  drupal_write_record('slashcomments_contents_karma', $record);
}

/**
 * Gets score modifier base on karma.
 *
 * Retrieves the score modifier for a content according to the karma its author 
 * had when the content has been posted.
 *
 * @param $content_id
 *   The identifier of the content
 *
 * @return
 *   An integer indicating the increase/decrease to apply to the score
 */
function _slashcomments_get_content_karma_modifier($content_id) {
  $sql = "SELECT km.modifier
    FROM {slashcomments_contents_karma} ck, {slashcomments_karma_modifier} km
    WHERE ck.karma BETWEEN km.karma_from AND km.karma_to
    AND content_id=%d";

  // Gets the modifier from the database
  $modifier = db_result(db_query($sql, $content_id));
  // Return the vale or 0 if it wasn't found
  return ($modifier) ? $modifier : 0;
}

/**
 * Calculates rating for a given content.
 *
 * @param $cid
 *   The content identifier
 *
 * @return
 *   An array with fhr following infos
 *   'content_id' => Identifier of the content
 *   'uid' => Identifier of the author
 *   'score' => Score assigned to the content
 *   'num_ratings' => Number of moderations/votes that contributed to the score
 *   'most_rated_id' => id of the moderation options that get more votes
 */
function slashcomments_calculate_rating($cid) {
  $rating = array();

  $sql = "
    SELECT  v.content_id, c.uid,
    SUM(o.score)  + CASE WHEN c.uid = 0 THEN %d ELSE %d  END score,
    count(*) num_ratings
    FROM {votingapi_vote} v, {slashcomments_rating_options} o,
    (SELECT uid FROM {comments} WHERE cid = %d) c
    WHERE v.content_type = 'comment' AND v.tag = 'slashcomments'
    AND v.value = o.rating_id AND v.content_id = %d
    GROUP BY v.content_id, c.uid
    ";

  // Get score info from the db
  $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(), $cid, $cid);
  $rating = db_fetch_array($result);

  // extrat most voted rating including only positive/negative
  // values depending on the score
  $rating['most_rated_id'] = '';
  $score_filter = $rating['score'] >= 1 ? ">= 0" : "< 0";

  $sql = "SELECT o.rating_id, count(*), max(v.timestamp)
    FROM {votingapi_vote} v, {slashcomments_rating_options} o
    WHERE v.value = o.rating_id
    AND v.content_type = 'comment' AND v.content_id = %d
    AND v.value_type = 'option' AND v.tag = 'slashcomments'
    AND o.score %s
    GROUP BY o.rating_id
    ORDER BY 2 DESC, 3 DESC, 1";

  $row = db_fetch_object(db_query_range($sql, $cid, $score_filter, 0, 1));

  // Add the most_rated_id and return the result
  $rating['most_rated_id'] = $row->rating_id;
  return $rating;
}

/**
 * Updates karma of a given user.
 *
 * @param $uid
 *   User identifier
 */
function slashcomments_update_karma($uid) {
  if ($uid == 0) {
    return;
  }

  // min and max rating considering when karma is calculated
  $comments_num = db_result(db_query("SELECT count(*) FROM {slashcomments_contents_rating} WHERE uid = %d", $uid));
  $comments_for_karma = _slashcomments_get_ratings_for_karma();
  $lowest_for_karma = _slashcomments_get_lowest_score_for_karma();
  $highest_for_karma = _slashcomments_get_highest_score_for_karma();
  $has_karma = slashcomments_user_has_karma($uid);

  // If moderated karma are not enough erase karma value and return
  if ($comments_num < $comments_for_karma) {
    if ($has_karma) {
      db_query("DELETE FROM {slashcomments_users_karma} WHERE uid = %d", $uid);
    }
    return;
  }

  // Query to extract karma
  $sql =  "SELECT AVG(CASE WHEN score <  %d THEN %d
    WHEN score > %d THEN %d
    ELSE score END ) karma,
      SUM(CASE WHEN score < 1 THEN 1 ELSE 0 END) negative,
      SUM(CASE WHEN score > 1 THEN 1 ELSE 0 END) positive
      FROM {slashcomments_contents_rating} r
      WHERE r.uid = %d
      HAVING count(*) >= %d";

  // Extract the data and fill missing fields
  $result = db_query($sql, $lowest_for_karma, $lowest_for_karma, $highest_for_karma, $highest_for_karma, $uid, $comments_for_karma);
  $record = db_fetch_object($result);
  $record->uid = $uid;
  $record->total = $comments_num;
  $record->neutral = $record->total - $record->positive - $record->negative;
  $record->modified = time();
  if ($has_karma) {
    $update = 'uid';
  }
  else {
    $update = NULL;
    $record->created = $record->modified;
  }

  // Store the new karma value in the db
  drupal_write_record('slashcomments_users_karma', $record, $update);
}

/*
 * Determines if user has karma.
 *
 * @param $uid
 *   User identifier
 *
 * @return
 *   TRUE if user has a karma value, FALSE otherwise
 */
function slashcomments_user_has_karma($uid) {
  $sql =  "SELECT count(*)
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $has_karma = db_result(db_query($sql, $uid));

  return ($has_karma) ? TRUE : FALSE;
}

/* 
 * Gets the current karma value of a given user.
 *
 * @param $uid
 *   User identifier whose karma has to be retrieved
 *
 * @return
 *   Current karma value for the user
 */
function slashcomments_get_user_karma($uid) {
  //return NULL;
  $sql =  "SELECT karma
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $karma = db_result(db_query($sql, $uid));

  if ($karma === FALSE OR $karma === NULL) {
    $karma = _slashcomments_get_default_karma();
  }
  return $karma;
}

/* 
 * Gets karma value to display.
 *
 * Gets the karma values to display on user profile and comments. The value can 
 * be different from the real karma has the displayed scale is smaller.
 *
 * @param $uid
 *   User identifier whose karma has to be retrieved
 *
 * @return
 *   Karma value to display
 */
function slashcomments_get_user_display_karma($uid) {
  $karma = slashcomments_get_user_karma($uid);
  $display_karma = ($karma < SLASHCOMMENTS_LOWEST_DISPLAY_RATING) ? SLASHCOMMENTS_LOWEST_DISPLAY_RATING 
    : (($karma > SLASHCOMMENTS_HIGHEST_DISPLAY_RATING) ?  SLASHCOMMENTS_HIGHEST_DISPLAY_RATING : $karma);
  return $display_karma;
}


/**
 * Implementation of hook_form_alter
 *
 * Modify comment settings form (available for each content type) and comment 
 * controls displayed, if enabled, above and below comments.
 */
function slashcomments_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form') {
    unset($form['comment_filter']['comment']['#title']);
  }

  // Add threshold option and override display mode option in the content type 
  // settings page.
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $form['comment']['comment_default_threshold'] = array(
      '#type' => 'select',
      '#title' => t('Default comments threshold'),
      '#default_value' => variable_get('comment_default_threshold_'. $form['#node_type']->type, SLASHCOMMENTS_DEFAULT_THRESHOLD),
      '#options' => _slashcomments_thresholds(),
      '#description' => t('Default threshold for comments. Comments with lower score will be collapsed.'),
      '#weight' => -5,
    );
    $form['comment']['comment_default_mode'] = array(
      '#type' => 'select',
      '#title' => t('Default display mode'),
      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, SLASHCOMMENTS_MODE_FLAT),
      '#options' => _slashcomments_modes(),
      '#description' => t('The default view for comments.'),
      '#weight' => -4,
    );
    $form['comment']['comment_default_per_page']['#weight'] = -3;

    //order is always oldest first
    unset($form['comment']['comment_default_order']);
  }

  // Add threshold option and override display mode option to comment controls form
  if ($form_id == 'comment_controls') {
    // WARNING: we cannot get node type from form info, so, we have to load from arg(1)
    $node = node_load(arg(1));

    $form['threshold'] = array(
      '#type' => 'select',
      '#title' => t('Threshold'),
      '#options' => _slashcomments_thresholds($node),
      '#default_value' => _slashcomments_get_display_setting('threshold', $node),
      '#weight' => 0,
    );

    $form['mode'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('mode', $node),
      '#options' => _slashcomments_modes(),
      '#weight' => 1,
    );

    //order is always oldest first
    $form['order'] = array(
      '#type' => 'hidden',
      '#value' => COMMENT_ORDER_OLDEST_FIRST,
    );

    $form['comments_per_page'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('comments_per_page', $node),
      '#options' => _slashcomments_per_page(),
      '#weight' => 3,
    );

    $form['#submit'][] = 'slashcomments_comment_control_submit';
  }
}

/**
 * Submit callback for comments control (threshold, mode, per page)
 */
function slashcomments_comment_control_submit($form, &$form_state) {
  global $user;
  $threshold = $form_state['values']['threshold'];
  $mode = $form_state['values']['mode'];
  $order = $form_state['values']['order'];
  $comments_per_page = $form_state['values']['comments_per_page'];

  if ($user->uid) {
    $account = user_save($user, array('threshold' => $threshold, 'mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }
  }

  $_SESSION['comment_threshold'] = $threshold;
  $_SESSION['comment_mode'] = $mode;
  $_SESSION['comment_sort'] = $order;
  $_SESSION['comment_comments_per_page'] = $comments_per_page;
}


/**
 * FAPI definition for the comment moderation form.
 *
 * @ingroup forms
 * @see slashcomments_moderation_form_submit()
 */
function slashcomments_moderation_form($form_state, $cid, $uid) {
  $form['cid'] = array('#type' => 'hidden', '#default_value' => $cid);
  $form['uid'] = array('#type' => 'hidden', '#default_value' => $uid);

  $form['vote'] = array(
    '#title' => '',
    '#type' => 'select',
    '#options' => _slashcomments_moderation_options(),
    '#default_value' => 0,
    '#weight' => 30
  );


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Moderate'),
    '#weight' => 50
  );

  $form['#submit'][] = 'slashcomments_moderation_form_submit';

  return $form;
}


/**
 * Implementation of hook_user().
 */
function slashcomments_user($op, &$edit, &$account, $category = 'account') {
  switch ($op) {
  case 'view':
    if (!_slashcomments_karma_enabled()) {
      break;
    }

    $user_karma = slashcomments_get_user_display_karma($account->uid);

    $account->content['slashcomments_karma'] = array(
      '#type' => 'user_profile_category',
      '#title' => t('Karma'),
      '#weight' => 10,
    );
    $account->content['slashcomments_karma']['karma'] = array(
      '#title' => t('Current value'),
      '#type' => 'user_profile_item',
      '#value' => $user_karma,
      '#weight' => 1,
    );
    break;
  }
}

/**
 * Implementation of hook_preprocess_comment
 *
 * Preprocesses template variables for the comment template. Adds comments 
 * rating information, moderation form and class for collapsed/expanded comments 
 * depending on the threshold.
 */
function slashcomments_preprocess_comment(&$variables) {
  global $user, $_slashcomments_ignore_threshold;

  $comment = $variables['comment'];
  if (!$comment->cid) {
    return;
  }

  // set the proper template to display comments
  _slashcomments_set_comment_template($variables);
  // get score and rating
  $rating = slashcomments_get_content_rating($comment->cid);

  $variables['slashcomments_rating'] = theme('slashcomments_rating', $rating);

  $reply = arg(0) == 'comment' && (arg(1) == 'reply' || arg(1) == 'edit');
  $can_vote = slashcomments_user_can_moderate($user->uid, $comment->cid);

  // Hide moderation module if user can't moderate or is on the edit or reply page
  if (!$reply && $can_vote['result'] == 1) {
    $variables['slashcomments_form'] = theme('slashcomments_form_wrapper', $comment->cid, $comment->uid, "");
    //_slashcomments_get_moderation_message(1,$comment->uid));
  }

  // add karma if it's enabled
  if (_slashcomments_karma_enabled()) {
    $variables['slashcomments_karma'] = theme('slashcomments_karma', slashcomments_get_user_display_karma($comment->uid));
  }

  // get default threshold for the content type
  $threshold = ($_slashcomments_ignore_threshold) ? -1 : _slashcomments_get_display_setting('threshold', $variables['node']);

  // fill out template variable used as css classes to display different kind of 
  // comments: collapsed, expanded, own
  if ($rating['score'] >= $threshold) {
    $variables['collapsed'] = '';
    $variables['toggle_label'] = 'non_toggle_label';
    $variables['toggle_area'] = 'non_toggle_area';
  }
  else {
    $variables['collapsed'] = 'collapsed';
    $variables['toggle_label'] = 'toggle_label';
    $variables['toggle_area'] = 'toggle_area';
  }
  $variables['toggle_label'] .= ' ' . $comment->own;
  $variables['toggle_area'] .= ' ' . $comment->own;

  // generate permalink
  $page_number = $_GET['page'];

  if (!$page_number) {
    $page_number = 0;
  }

  $fragment = 'comment-' . $variables['comment']->cid;
  $query = ($page_number) ? 'page=' . $page_number : NULL;
  $img_path = _slashcomments_get_image_path();
  $linktext = '<img src="' . $img_path . '/permalink.gif" />';
  $linkpath = 'node/' . $variables['node']->nid;
  $variables['comment_link'] = l($linktext, $linkpath, array('query' => $query, 'fragment' => $fragment, 'html' => TRUE));

  // Link to page created by Comment Page module, if it exists
  $variables['page_link'] = '';
  if (!empty($variables['comment']->page_url) && !(arg(0) == 'comment' && arg(1) == $variables['comment']->cid)) {
    $variables['page_link'] = l(t('(permalink)'), $variables['comment']->page_url);
  }
}

/**
 * Overrides theme_comment_view()
 */
function slashcomments_comment_view($comment, $node, $links = array(), $visible = TRUE) {
  static $first_new = TRUE;
  $output = '';
  $comment->new = node_mark($comment->nid, $comment->timestamp);
  if ($first_new && $comment->new != MARK_READ) {
    // Assign the anchor only for the first new comment. This avoids duplicate
    // id attributes on a page.
    $first_new = FALSE;
    $output .= "<a id=\"new\"></a>\n";
  }

  //$output .= "<a id=\"comment-$comment->cid\"></a>\n";
  $comment->comment = check_markup($comment->comment, $comment->format, FALSE);

  // Comment API hook
  comment_invoke_comment($comment, 'view');
  $output .= theme('comment', $comment, $node, $links);
  return $output;
}

/**
 * Implementation of hook_comment().
 */
function slashcomments_comment($comment, $op) {
  switch ($op) {
  case 'view':
    global $user;

    // marke comments of the user in order to theme them differently
    if ($user->uid == $comment->uid && $user->uid != 0) {
      $comment->own = "own";
    }
    break;
  case 'insert':
    // if karma is enable apply a modifier to the initial comment rating
    if (_slashcomments_karma_enabled()) {
      slashcomments_init_contents_karma($comment['cid'], $comment['uid']);
    }

    break;
  case 'delete':
    // Delete slashcomments data stored for the comment
    slashcomments_delete_rating($comment->cid);
    break;
  }
}


/**
 * Implementation of hook_preprocess_author_pane().
 */
function slashcomments_preprocess_author_pane(&$variables) {
  _slashcomments_set_author_pane_template($variables);

  // Add karma to template variables
  if (_slashcomments_karma_enabled()) {
    $variables['slashcomments_karma'] = slashcomments_get_user_display_karma($variables['account']->uid);
  }
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function slashcomments_theme_registry_alter($theme_registry) {
  // replace the theme function for comment_view */
  if (!empty($theme_registry['comment_view'])) {
    $theme_registry['comment_view']['function'] = 'slashcomments_comment_view';
  }

  // replace the theme function for collapsed view with expanded view */
  if (!empty($theme_registry['comment_flat_collapsed'])) {
    $theme_registry['comment_flat_collapsed']['function'] = 'theme_comment_flat_expanded';
  }
  if (!empty($theme_registry['comment_thread_collapsed'])) {
    $theme_registry['comment_thread_collapsed']['function'] = 'theme_comment_thread_expanded';
  }

  // Code ported from the advanced forum module
  // --- The following section manipulates the theme registry so the .tpl files
  // --- for the given templates can be found first in the (sub)theme directory
  // --- then in ancestor themes, if any, and finally in the slashcomments folder.

  // Affected templates
  $templates = array('comment', 'author_pane');

  // Find all our ancestor themes and put them in an array.
  global $theme;
  $themes = list_themes();

  $ancestor_paths = array();
  $ancestor = $theme;
  while ($ancestor && isset($themes[$ancestor]->base_theme)) {
    array_unshift($ancestor_paths, dirname($themes[$themes[$ancestor]->base_theme]->filename));
    $ancestor = $themes[$ancestor]->base_theme;
  }
  $module_path = drupal_get_path('module', 'slashcomments') . '/templates';

  foreach ($templates as $template) {
    // Sanity check in case the template is not being used.
    if (is_array($theme_registry[$template])) {
      // If there was a path in there, store it.
      $existing_path = array_shift($theme_registry[$template]['theme paths']);
      array_unshift($theme_registry[$template]['theme paths'], $existing_path, $module_path);

      // If there are any ancestor paths (ie: we are in a subtheme, add those)
      foreach ($ancestor_paths as $ancestor_path) {
        $theme_registry[$template]['theme paths'][] = $ancestor_path;
      }
      //Put the active theme's path last since that takes precidence.
      $theme_registry[$template]['theme paths'][] = path_to_theme();
    }
  }
}

/*
 * Themes the status message displayed when a message is moderated
 *
 * @parma $result
 *  Array with the status and message to display
 *    'result => "ok" or "error" according to the moderation result
 *    'message' => message displayed to the user
 *
 * @return
 *  HTML for the message to display after moderation
 */
function theme_slashcomments_moderation_status($result) {
  $class = ($result['result']) ? 'ok' : 'error';
  $output = '<div class="messages ' . $class . '">';
  $output .= $result['message'];
  $output .= '</div>';

  return $output;
}


/**
 * Themes slashcomments_rating and score. 
 * 
 * Themes the rating, score and help button displayed on each comment header
 *
 * @param $rating
 *  Array with rating information:
 *    'rating' => Text description of the most voted rating
 *    'score' => Score for the comment
 *
 * @return
 *  HTML for the rating, score and help button
 */
function theme_slashcomments_rating($rating) {
  $icon_url = _slashcomments_get_image_path() . '/question_mark.png';
  $icon_url_2 = _slashcomments_get_image_path() . '/forbidden.png';
  $help_page = url(_slashcomments_get_help_page_path());

  $output = '<span class="scomments_rating">';
  $output .= '(' . t('Score') . ': ' . $rating['score'];
  $output .= ($rating['rating']) ? ' ' . $rating['rating'] : '';
  $output .= '<a alt="What is this?" title="What is this?" href="' . $help_page . '"><img class="help_icon" src="'. $icon_url .'" /></a>';
  //$output .= '<a alt="What is this?" title="What is this?" href="' . $help_page . '"><img class="help_icon" src="'. $icon_url_2 .'" /></a>';
  $output .= ')';
  $output .= '</span>';

  return $output;
}


/*
 * Themes karma
 *
 * @parma $karma
 *   Karma value
 *
 * @return
 *   HTML to display karma
 */
function theme_slashcomments_karma($karma) {
  return '<p class="slashcomments-karma">' . t('Karma') . ': ' . $karma . '</p>';
}


/**
 * Themes the moderation form.
 *
 * Themes the form container and the form used to moderated comments.
 *
 * @param $cid
 *   Comment id of the comment the form will moderate
 *
 * @param $uid
 *   User id of the user displaying the page
 *
 * @param $message
 *   Status message to display below the form (not currently used)
 *
 * @return
 *   -HTML to display the form to moderate comments
 */
function theme_slashcomments_form_wrapper($cid, $uid, $message) {
  $output =  '<div id="slashcomments-form-wrapper-' . $cid . '" class="scomments_container">';
  $output .= '<div class="container-inline">';
  $output .= '<div class="scomments_form">' .  drupal_get_form('slashcomments_moderation_form', $cid, $uid) . '</div>';
  $output .= '<div class="scomments_loader"></div>';
  $output .= '<div class="scomments_form_status description">' . $message . '</div>';
  $output .= '</div></div>';
  return $output;
}

/**
 * Gets the template file to use for comments.
 *
 * Return the proper template to use for theming comments. It handle the 
 * presence of standard comments and advanced forum (v1.0 and v2.0).
 *
 * @param $used_tpl_file
 *   The name of the template file read from the theme registry.
 *
 * @return
 *   The name of the template to use.
 */
function _slashcomments_get_comment_template($used_tpl_file) {

  $tpl_files = array(
    "advf-forum-post"       => "slashcomments-advf-post-1x",
    "advanced_forum.post"   => "slashcomments-advf-post-2x"
  );

  return ($tpl_files[$used_tpl_file]) ? $tpl_files[$used_tpl_file] : "slashcomments-comment";
}


/* 
 * Retrieves the right template for comments and set it.
 *
 * @param $variables
 *  Variables preprocessed by comment preprocess function
 *
 * @return 
 *  NULL
 */
function _slashcomments_set_comment_template(&$variables) {
  static $new_tpl_file; // keep the template in case multiple calls

  if (empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_comment_template($used_tpl_file);
    _slashcomments_add_comment_template_files($new_tpl_file);
  }
  $variables['template_files'][] = $new_tpl_file;
}

/* Includes external files (javascript and stylesheets
 * needed for the chosen template.
 *
 * @param $new_tpl_file
 *   The template file that is going to be used for displaying comments
 *
 * @return
 *   NULL
 */
function _slashcomments_add_comment_template_files($new_tpl_file) {

  // add base url and other needed js variables
  drupal_add_js(
    array(
      'baseUrl'  => url($GLOBALS['base_url']),
      'slashdot' => array('error_status' => t("Error moderationg comment"),
      'load_image_path' => _slashcomments_get_image_path() . '/loading.gif')
    ),
    'setting'
  );

  drupal_add_js(drupal_get_path('module', 'slashcomments') .'/scripts/slashcomments.js');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/slashcomments.css');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
}


/**
 * Gets the template file to use for the author pane.
 *
 * Gets the proper template to use based on the fact advanced form is present 
 * and the fact author pane is in stacked mode.
 *
 * @param $used_tpl_file
 *   Template file currently in use.
 *
 * @return
 *   Template file that is going to be used.
 */
function _slashcomments_get_author_pane_template($used_tpl_file) {

  $tpl_files = array(
    "advf-author-pane"                    => "slashcomments-advf-author-pane-1x",
    "advf-author-pane-stacked"             => "slashcomments-advf-author-pane-stacked-1x",
    "advanced_forum.author-pane"          => "slashcomments-advf-author-pane-2x",
    "advanced_forum.author-pane-stacked"  => "slashcomments-advf-author-pane-stacked-2x",
    "author-pane"                         => "slashcomments-author-pane"
  );

  // Replace the template file with the version provided by slashcomments
  if (module_exists("advanced_forum") && strpos(advanced_forum_get_current_style(), 'stacked')) {
    $used_tpl_file .= "-stacked";
  }
  return $tpl_files[$used_tpl_file];
}

/* 
 * Retrieves the right template for author_pane and set it.
 *
 * @param $variables
 *   Variables processed by author_pane preprocess functions.
 */
function _slashcomments_set_author_pane_template(&$variables) {
  static $new_tpl_file;

  if (empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_author_pane_template($used_tpl_file);
    drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
  }
  $variables['template_files'][] = $new_tpl_file;
}

/**
 * Get available ratings
 *
 * @return
 *  Array of available ratings. Array keys are rating id and values are 
 *  ratings descriptions
 */
function _slashcomments_moderation_options() {
  static $rating_options;

  // query the database only once for each request
  if (!$rating_options) {
    /* extract enabled ratings from the db */
    $sql = "SELECT rating_id, rating
      FROM {slashcomments_rating_options}
      WHERE enabled = 1
      ORDER BY weight
      ";

    $db_ratings = db_query($sql);

    $rating_options = array();
    while ($rating = db_fetch_object($db_ratings)) {
      $rating_options[$rating->rating_id] = $rating->rating;
    }
  }
  return $rating_options;
}

/* 
 * Retrieves thresholds for node and settings.
 *
 * @node 
 *  Node being displayed. Used to calculate how many comments will be 
 *  displayed for each selected threshold
 *
 * @retunrn
 *  Array of available options to be used in a drop-down list
 */
function _slashcomments_thresholds($node = NULL) {

  // Possible threshold value
  $thresholds = array(-1, 1, 2, 3 , 4, 5);
  $options = array();

  if (!$node) {
    // if node isn't passed to the function we're in the seetings panel
    // for the content type no need to calculate the number of comments
    foreach ($thresholds as $i) {
      $options[$i] = t('Threshold: !n', array('!n' => sprintf("%+d", $i)));
    }
  }
  else {
    $comments_per_rating = array();
    foreach ($thresholds as $i) {
      $comments_per_rating[$i] = 0;
    }

    $rating_field = 'score';
    if (_slashcomments_karma_enabled()) {
      $sql = "
        SELECT score, count(*) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END)+IFNULL(m.modifier, 0) score
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          LEFT JOIN {slashcomments_contents_karma} k
          ON c.cid = k.content_id
          LEFT JOIN {slashcomments_karma_modifier} m
          ON k.karma >= m.karma_from AND k.karma <= m.karma_to
          WHERE c.nid = %d
        ) a
        GROUP BY score";
    }
    else {
      $sql = "SELECT score, count(*) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END) score
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          WHERE c.nid = %d
        ) a
        GROUP BY score";
    }

    $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(),  $node->nid);

    while ($data = db_fetch_object($result)) {
      $comments_per_rating[$data->score] = $data->num;
    }
    $comments_per_rating[-1] = $node->comment_count;

    for ($i = 6; $i>0; $i--) {
      $comments_per_rating[$i - 1] = $comments_per_rating[$i - 1] + $comments_per_rating[$i];
    }
    foreach ($thresholds as $i) {
      $options[$i] = t('!n: !s comments', array('!n' => sprintf("%+d", $i), '!s' => $comments_per_rating[$i]));
    }
  }
  return $options;
}

/*
 * Gets available options for displayng comments.
 *
 * @return
 *  Array of available options
 */
function _slashcomments_modes() {
  return array(
    SLASHCOMMENTS_MODE_FLAT => t('Display: flat'),
    SLASHCOMMENTS_MODE_THREADED => t('Display: threaded'),
  );
}

/*
 * Gets available options for number of comments to show in each page
 *
 * @return 
 *  Arrays of available options
 */
function _slashcomments_per_page() {
  $per_page = array(10, 30, 50, 70, 90, 150, 200, 250, 300, 1000);
  $options = array();
  foreach ($per_page as $i) {
    $options[$i] = t('!a per page', array('!a' => $i));
  }
  return $options;
}

/**
 * Gets display settings for a given content
 */
function _slashcomments_get_display_setting($setting, $node) {
  global $user;

  if (isset($_GET[$setting])) {
    $value = $_GET[$setting];
  }
  else {
    // get the setting's site default
    switch ($setting) {
    case 'threshold':
      $default = variable_get('comment_default_threshold_'. $node->type, SLASHCOMMENTS_DEFAULT_THRESHOLD);
      break;
    case 'mode':
      $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);
      break;
    case 'sort':
      $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_OLDEST_FIRST);
      break;
    case 'comments_per_page':
      $default = variable_get('comment_default_per_page_'. $node->type, 50);
    }
    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {
      // if comment controls are disabled use site default
      $value = $default;
    }
    else {
      // otherwise use the user's setting if set
      if (isset($user->$setting) && $user->$setting) {
        $value = $user->$setting;
      }
      elseif (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {
        $value = $_SESSION['comment_'. $setting];
      }
      else {
        $value = $default;
      }
    }
  }
  return $value;
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_newbie() {
  return variable_get('slashcomments_limit_newbie', SLASHCOMMENTS_LIMIT_NEWBIE);
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_karma() {
  return variable_get('slashcomments_limit_karma', SLASHCOMMENTS_LIMIT_KARMA);
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_takepart() {
  return variable_get('slashcomments_limit_takepart', SLASHCOMMENTS_LIMIT_TAKEPART);
}

/* Gets values of the default_score settings variable */
function _slashcomments_get_default_score() {
  return variable_get('slashcomments_default_score', SLASHCOMMENTS_DEFAULT_SCORE);
}

/* Gets values of the default_score_anonymous settings variable */
function _slashcomments_get_default_score_anonymous() {
  return variable_get('slashcomments_default_score_anonymous', SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS);
}

/* Gets values of the default_karma settings variable */
function _slashcomments_get_default_karma() {
  return variable_get('slashcomments_default_karma', SLASHCOMMENTS_DEFAULT_KARMA);
}

/* Gets values of the rating_for_karma settings variable */
function _slashcomments_get_ratings_for_karma() {
  return variable_get('slashcomments_ratings_for_karma', SLASHCOMMENTS_RATINGS_FOR_KARMA);
}

/* Gets values of the mod_per_day settings variable */
function _slashcomments_get_mod_per_day() {
  return variable_get('slashcomments_mod_per_day', SLASHCOMMENTS_MOD_PER_DAY);
}

/* Gets values of the help_page_path settings variable */
function _slashcomments_get_help_page_path() {
  return variable_get('slashcomments_help_page_path', SLASHCOMMENTS_HELP_PAGE_PATH);
}

/* Gets values of the lowest rating for karma settings variable */
function _slashcomments_get_lowest_score_for_karma() {
  return variable_get('slashcomments_lowest_score_for_karma', SLASHCOMMENTS_LOWEST_SCORE_FOR_KARMA);
}

/* Gets values of the highest rating for karma settings variable */
function _slashcomments_get_highest_score_for_karma() {
  return variable_get('slashcomments_highest_score_for_karma', SLASHCOMMENTS_HIGHEST_SCORE_FOR_KARMA);
}

/* Getss value of the enable karma variables */
function _slashcomments_karma_enabled() {
  return variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1;
}

/* Gets the url of slashcomments images folder */
function _slashcomments_get_image_path() {
  static $image_path;
  if (!$image_path) {
    $image_path = $GLOBALS['base_url'] . '/' . drupal_get_path('module', 'slashcomments') . '/images';
  }
  return $image_path;
}

/*
 * Gets moderation point for aq given user
 *
 * @param $uid
 *  Identifier of the user we're retrieving points for
 *
 * @return
 *  Number of moderation points left. It returns 
 *  SLASH_COMMENTS_INFINITE_MOD_POINTS for user with the 'bypass moderation 
 *  restriciton' permission
 */
function slashcomments_get_user_mod_points($uid) {

  // Infinite moderation if user bypass restriction or if it's been set that way
  if (user_access('bypass moderation restriction') || $uid == 1
    || _slashcomments_get_mod_per_day() == SLASHCOMMENTS_INFINITE_MOD_POINTS) {
      return SLASHCOMMENTS_INFINITE_MOD_POINTS;
    }

  // Gets user mod points from the db
  $sql = "SELECT uid, points, assigned
    FROM {slashcomments_users_mod_points}
    WHERE uid = %d";


  $data = db_fetch_array(db_query($sql, $uid));

  if (!$data) {
  // If user has no points yet assing them 
    $points = slashcomments_assign_user_mod_points($uid, 1);
  }
  elseif (time() - $data['assigned'] > (60*60*24)) {
  // If needed time has passed assign new points to the user
    $points =  slashcomments_assign_user_mod_points($uid, 0);
  }
  else {
    // otherwise return points stored
    $points = $data['points'];
  }

  return $points;
}

/*
 * Assign moderation points to a given user
 *
 * @param $uid
 *  Identifier of the user points will be assigned
 *
 * @paran $new
 *  1 if the user has never been assigned points
 *  0 if the user has being assigned points before
 *
 * @return
 *  Number of points assigned
 */
function slashcomments_assign_user_mod_points($uid, $new = -1) {
  if ($new == -1) {
    $new = !db_result(db_query("SELECT count(*) FROM {slashcomments_users_mod_points}"));
  }
  $record['uid'] = $uid;
  $record['points'] = _slashcomments_get_mod_per_day();
  $record['modified'] = $record['assigned'] = time();
  if ($new) {
    $record['created'] = $record['modified'];
  }
  else {
    $update = 'uid';
  }
  drupal_write_record('slashcomments_users_mod_points', $record, $update);
  return slashcomments_get_user_mod_points($uid);
}

/*
 * Checks if user has moderation points left
 *
 * @return
 *  TRUE or FALSE depending or wheter the user has points left
 */
function _slashcomments_user_has_mod_points($uid) {
  $points = slashcomments_get_user_mod_points($uid);
  return ($points > 0 || $points == SLASHCOMMENTS_INFINITE_MOD_POINTS) ? TRUE : FALSE;
}

/*
 * Consume a moderation point.
 *
 * @param $uid
 *  Identifier of the user 
 */
function slashcomments_use_mod_point($uid) {
  if (user_access('bypass moderation restriction') || $uid == 1) {
    return;
  }

  $sql = "UPDATE {slashcomments_users_mod_points}
    SET points = CASE WHEN points = 0 THEN 0 ELSE points-1 END
    WHERE uid = %d";

  db_query($sql, $uid);
}

/* 
 * Get moderation strings according to the result of moderationn
 *
 * @param $code
 *  Result code of the moderation has returned from the can_moderate funtion
 *
 * @parma $uid
 *  Identifier of the user the message has been displayed to
 *
 * @return
 *  Text message related to user status regarding moderation
 */
function _slashcomments_get_moderation_message($code, $uid) {
  global $user;

  $message = "";

  switch ($code) {
  case -1 :
    $message = t("You don't have permission to moderate this comment");
    break;
  case -2 :
    $message = t("You need a karma value of !karma before you can moderate this comment",
      array('!karma' => _slashcomments_get_limit_karma()));
    break;
  case -3 :
    $assigned = db_result(db_query("SELECT assigned FROM {slashcomments_users_mod_points} WHERE uid = %d", $uid));

    $time_str = slashcomments_get_time_str(60*60*24 - (time() - $assigned));
    $message = t("You don't have any moderation point. You'll get more in !timeleft",
      array("!timeleft" => $time_str));
    break;
  case -4 :
    $message = t("You can't moderate comments on your own content");
    break;
  case -5 :
    $time_str = slashcomments_get_time_str($user->created - strtotime("-" . _slashcomments_get_limit_newbie() . " day"));
    $message = t("Being a new user you have to wait !timeleft before you can moderate",
      array("!timeleft" => $time_str));
    break;
  case -6 :
    $message = t("You have already moderated this comment");
    break;
  case -7 :
    $message = t("You can't moderate comments on contents you commented");
    break;
  case -8 :
    $message = t("You can't moderate your own comment");
    break;
  case 1 :
    if (_slashcomments_get_mod_per_day) {
      $mod_points = slashcomments_get_user_mod_points($uid);
      if ($mod_points) {
        if ($mod_points == SLASHCOMMENTS_INFINITE_MOD_POINTS) {
          //$mod_points = t('unlimited');
          $message = '';
        }
        else {
          $message = t("You have !modpoints moderation points left",
            array('!modpoints' => $mod_points));
        }
      }
      else {
        $assigned = db_result(db_query("SELECT assigned FROM {slashcomments_users_mod_points} WHERE uid = %d", $uid));

        $time_str = slashcomments_get_time_str(60*60*24 - (time() - $assigned));
        $message = t("You don't have any moderation point. You'll get more in !timeleft",
          array("!timeleft" => $time_str));
      }
    }
    break;
  }

  return $message;
}

/*
 * Returns days,  hours and minutes correspondings 
 * to seconds in a given timestamp.
 *
 * @param $timestamp
 *  Seconds to be splitted in days, hours and minutes
 *
 * @return
 *  String representation of given seconds in the format
 *  x days y hours z minutes
 */
function slashcomments_get_time_str($timestamp) {
  $secs_per_day = 60*60*24;
  $secs_per_hour = 60*60;

  $days = (int)($timestamp / $secs_per_day);
  $timestamp -= $days * $secs_per_day;
  $hours = (int)($timestamp  / $secs_per_hour);
  $timestamp -= $hours * $secs_per_hour;
  $minutes = (int)($timestamp / 60);

  $output = "";
  if ($days) {
    $output .= $days . ' ' . t('Days');
  }
  if ($hours) {
    if ($days) $output .= ' ';
    $output .= $hours . ' ' . t('Hours');
  }
  if ($minutes) {
    if ($hours) $output .= ' ';
    $output .= $minutes . ' ' . t('Minutes');
  }
  return $output;
}

/*
function slashcomments_upodate_all_ratings() {
  $sql = "SELECT DISTINCT cid
    FROM {votingapi_vote} v
    WHERE v.content_type = 'comment' AND v.tag = 'slashcomments'
    AND v.value = o.rating_id AND v.content_id = %d";

  $result = db_query($sql);

  while ($cid = db_fetch_array($result)) {
    slashcomments_update_rating($cid);
  }
}*/

