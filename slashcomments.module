<?php
/**
 * @file
 * The slashcomments module enanche the default commenting system with some of
 * the features of the slashdot moderation system (moderation, karma, view by
 * threshold
 */

// Fixed costants used by the module - settings are not available
// Commnet flat and trheaded display
define('SLASHCOMMENTS_MODE_FLAT', 2);
define('SLASHCOMMENTS_MODE_THREADED', 4);
// Value to represent that a user has infinite moderation points
define('SLASHCOMMENTS_INFINITE_MOD_POINTS', -1);
// Lowest and highest displayed score (not the actual score stored in the db)
define('SLASHCOMMENTS_LOWEST_DISPLAY_RATING', -1);
define('SLASHCOMMENTS_HIGHEST_DISPLAY_RATING', 5);

// Module settings - can be configured through the administration page
// Comment default rating
define('SLASHCOMMENTS_DEFAULT_SCORE', 1);
define('SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS', 0);
// Default threshold for displaying comments
define('SLASHCOMMENTS_DEFAULT_THRESHOLD', 2);
//  limit moderation from participating users
define('SLASHCOMMENTS_LIMIT_TAKEPART', 1);
// days before newbie users can post
define('SLASHCOMMENTS_LIMIT_NEWBIE', 14);
// enable karma
define('SLASHCOMMENTS_ENABLE_KARMA', 1);
// limit moderation based on karma value
define('SLASHCOMMENTS_LIMIT_KARMA', 2);
// initial karma value
define('SLASHCOMMENTS_DEFAULT_KARMA', 1);
// numbers of moderated comment for having karma
define('SLASHCOMMENTS_RATINGS_FOR_KARMA', 10);
// numbers of moderation points per day
define('SLASHCOMMENTS_MOD_PER_DAY', 10);
// default path for the help page
define('SLASHCOMMENTS_HELP_PAGE_PATH', 'slashcomments/help');
// Lower score valid for karma
define('SLASHCOMMENTS_LOWEST_SCORE_FOR_KARMA', -6);
// Higher score valid for karma
define('SLASHCOMMENTS_HIGHEST_SCORE_FOR_KARMA', 8);

// user can moderate status
define('USER_CAN_MODERATE',     1);
define('NO_MOD_PERMISSION',     2);
define('IS_NEWBIE',             4);
define('LOW_KARMA',             8);
define('NO_MOD_POINTS',         16);
define('USER_IS_NODE_AUTHOR',   32);
define('ALREADY_MODERATED',     64);
define('TOOK_PART',             128);
define('OWN_COMMENT',           256);


/**
 * Implementation of hook_views_api().
 */
function slashcomments_views_api() {
  return array('api' => 2.0,
    'path' => drupal_get_path('module', 'slashcomments') . '/includes/views');
}

/**
 * Implementation of hook_menu().
 */
function slashcomments_menu() {
  $items = array();

  // Add the callback for AJAX moderation
  $items['slashcomments/moderate'] = array(
    'title' => 'Slashcomments - AJAX moderation',
    'page callback' => 'slashcomments_moderate',
    'access callback' => 'slashcomments_moderate_access',
    'type' => MENU_CALLBACK,
  );

  // Add the callback for AJAX dismiss of notifications
  $items['slashcomments/dismiss_notification'] = array(
    'title' => 'Slashcomments - Dismiss Notification',
    'page callback' => 'slashcomments_dismiss_notification',
    'access callback' => 'slashcomments_moderate_access',
    'type' => MENU_CALLBACK,
  );

  // Add the callback for loading comment with AJAX
  $items['slashcomments/load_comment'] = array(
    'title' => 'Slashcomments - AJAX commet loading',
    'page callback' => 'slashcomments_load_comment',
    'access arguments' => array('access comments'),
    'type' => MENU_CALLBACK,
  );

  // Add the callback for the settings page
  $items['admin/settings/slashcomments'] = array(
    'title' => 'Slashcomments',
    'description' => 'Configure slashcomments',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_general_form'),
    'access arguments' => array('administer slashcomments'),
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the Genral Tab to the settings page
  $items['admin/settings/slashcomments/general'] = array(
    'title' => 'General',
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer slashcomments'),
  );

  // Add the Karma tab to the settings page
  $items['admin/settings/slashcomments/karma'] = array(
    'title' => 'Karma',
    'weight' => 1,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_karma_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );

  // Add the Ratings tab to the settings page
  $items['admin/settings/slashcomments/ratings'] = array(
    'title' => 'Ratings',
    'weight' => 2,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slashcomments_admin_ratings_form'),
    'access arguments' => array('administer slashcomments'),
    'type' => MENU_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    'file' => 'slashcomments.admin.inc',
  );


  // Add the callback to the public help page
  $items['slashcomments/help'] = array(
    'title' => 'Slashcomments Help Page',
    'page callback' => 'theme',
    'page arguments' => array('slashcomments_help'),
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
    //'file path' => drupal_get_path('module', 'slashcomments') . '/includes/',
    //'file' => 'slashcomments_help.inc',
  );

  return $items;
}

function template_preprocess_slashcomments_help(&$variables) {
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/slashcomments.css');
  $variables['moderations_points'] = _slashcomments_get_mod_per_day();
  $variables['limit_take_part'] = _slashcomments_get_limit_takepart();
}

function slashcomments_enable() {
  $batch  = array(
    'operations' => array(
      array('slashcomments_batch_init_ratings', array()),
      array('slashcomments_batch_update_users_stats', array()),
    ),
    'finished' => 'slashcomments_batch_init_ratings_finished',
    'title' => t('Update or initialize slashcomments data structure.'),
    'init_message' => t('Data update is starting.'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Data update has encountered an error.'),
    'file' => drupal_get_path('module', 'slashcomments') . '/includes/batch.inc',
  );

  batch_set($batch);
}


/**
 * Implementation of hook_theme().
 */
function slashcomments_theme() {
  // Theme comments
  $items['slashcomments_comment'] = array(
    'template' => 'slashcomments-comment',
  );

  // Theme the default help page
  $items['slashcomments_help'] = array(
    'template' => 'slashcomments-help',
    'path' => drupal_get_path('module', 'slashcomments') . '/templates',
  );

  // Theme the moderation form wrapper
  $items['slashcomments_form_wrapper'] = array(
    'arguments' => array('cid' => NULL, 'uid' => NULL, 'show_form' => TRUE, 'message' => NULL),
  );

  // Theme the form in the Ratings settings page
  $items['slashcomments_admin_ratings_form'] = array(
    'arguments' => array('form' => NULL),
  );

  // Theme comment rating and score
  $items['slashcomments_rating'] = array(
    'arguments' => array('rating' => NULL),
  );

  // Theme moderation result
  $items['slashcomments_post_moderation_status'] = array(
    'arguments' => array('status_result' => NULL),
  );

  // Theme moderation message shows for every message
  $items['slashcomments_comment_moderation_status'] = array(
    'arguments' => array('status_result' => NULL),
  );

  // Theme karma
  $items['slashcomments_karma'] = array(
    'arguments' => array('karma' => NULL),
  );


  // Theme notification
  $items['slashcomments_notification'] = array(
    'template' => 'slashcomments-notification',
    'path' => drupal_get_path('module', 'slashcomments') . '/templates',
    'arguments' => array('title' => NULL, 'body' => NULL),
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function slashcomments_perm() {
  return array('moderate comments', 'administer slashcomments',
    'bypass moderation restriction');
}

/**
 * Implements access callback for moderatiing comments
 */
function slashcomments_moderate_access() {
  return user_access('access content') &&
    (user_access('moderate comments') || user_access('bypass moderation restriction'));
}


/**
 * Determines if a given user can moderate comments.
 *
 * According to user's role permission, karma, and other slashcomments settings
 * determine if a user should be allowed to moderate comments.
 *
 * @param $uid
 *  User id of the user who's going to be checked
 *
 * @return
 *  Binary number representing the result of the check
 */


function slashcomments_user_can_moderate($uid) {

  static $result = 0;

  // keeps the status to avoid executing them multiple times during comment
  // rendering
  if ($result != 0) {
    return $result;
  }

  /* skip controls for the super user or user with specific permissions*/
  $bypass = user_access('bypass moderation restriction');

  if (user_access('administer slashcomments') || $uid == 1 || $bypass) {
    $result |= USER_CAN_MODERATE;
    return $result;
  }

  global $user;

  // check user has the needed permissiCon
  if (!user_access('moderate comments')) {
    $result |= NO_MOD_PERMISSION;
  }

  // check if user is still a new bie
  if (strtotime("-" . _slashcomments_get_limit_newbie() . " day") < $user->created) {
    $result |= IS_NEWBIE;
  }

  // check if user has the needed karma
  if (_slashcomments_karma_enabled()
    && slashcomments_get_user_karma($uid) < _slashcomments_get_limit_karma()) {
      $result |= LOW_KARMA;
    }

  // check if the user has enough moderation points
  if (!_slashcomments_user_has_mod_points($uid)) {
    $result |= NO_MOD_POINTS;
  }

  // If all steps are passed user can moderate
  if ($result == 0) {
    $result |= USER_CAN_MODERATE;
  }
  return $result;
}

/**
 * Determines if a given user can moderate a specific comment.
 *
 * According to user's status deternines
 * ifa user should be allowed to moderate a specific comment.
 *
 * @param $uid
 *  User id of the user who's going to be checked
 *
 * @parma $cid
 *  Comment id of the comment the user need to moderate
 *
 * @return
 *  Binary number representing the result of the check
 */
function slashcomments_user_can_moderate_comment($uid, $cid) {

  $result = slashcomments_user_can_moderate($uid);

  if ($result != USER_CAN_MODERATE ||
    user_access('administer slashcomments') || $uid == 1) {
      return $result;
    }

  $bypass = user_access('bypass moderation restriction');

  $node_author = db_result(db_query("SELECT n.uid FROM {comments} c, {node} n WHERE c.cid=%d AND c.nid = n.nid", $cid));
  if ($node_author == $uid) {
    $result |= USER_IS_NODE_AUTHOR;
  }

  if ($vote = votingapi_select_votes(array('content_type' => 'comment',
    'content_id' => $cid, 'uid' => $uid, 'tag' => 'slashcomments'))) {
      $result |= ALREADY_MODERATED;
    }

  // When the option is set check if the user has already commented the node
  if (!$bypass && _slashcomments_get_limit_takepart()) {
    $sql = "SELECT count(*) cnt FROM {comments} c WHERE uid = %d AND nid
      = (SELECT t.nid FROM {comments} t WHERE t.cid = %d)";

    // get user's comments with nid
    $user_cid = db_result(db_query($sql, $uid, $cid));
    if ($user_cid != 0) {
      $result |= TOOK_PART;
    }
  }
  else {
    // get nid of the discussion
    $nid = db_result(db_query("SELECT count(*) FROM {comments} WHERE cid=%d AND uid=%d", $cid, $uid));
    if ($nid != 0) {
      $result |= OWN_COMMENT;
    }
  }

  return $result;
}

/**
 * Loads a single comment
 *
 * This callback is called when a collapsed comment is expanded for the first
 * time. It loads the comment body and return it to the javascript function to
 * be displayed
 */
function slashcomments_load_comment() {
  // If expected parameter are not sent in the HTTP request return
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])) {
    return;
  }

  // Force rendering of comment body even if it's score is below theshold
  global $_slashcomments_ignore_threshold;
  $_slashcomments_ignore_threshold = 1;

  // load the parent node of the comment
  $nid = db_result(db_query("SELECT nid FROM {comments} WHERE cid = %d", $_POST['cid']));
  if (!$nid) return;

  $node = node_load($nid);

  // retrieve comment output
  $out = comment_render($node, $_POST['cid']);

  // Make the result available for the ajax handler
  drupal_json(array(
    'status' => 'OK',
    'message' => $out,
  ));

  // Restore standard rendering
  $_slashcomments_ignore_threshold = 0;
  exit();
}

/**
 * Moderates a comment.
 *
 * This callback is called through AJAX when the moderate form is submitted.
 */
function slashcomments_moderate() {
  global $user;

  // If expected parameter are not sent in the HTTP request return
  if (empty($_POST['js']) || !is_numeric($_POST['cid'])
    || !is_numeric($_POST['uid']) || !is_numeric($_POST['vote']) ) {
      return;
    }

  // save the moderation
  $result = slashcomments_store_vote($_POST['cid'], $_POST['vote']);
  if (!$result['result']) {
    drupal_json(array(
      'status' => 'OK',
      'message' => theme('slashcomments_post_moderation_status', $result),
      'hide_forms' => !_slashcomments_user_has_mod_points($user->uid),
    ));
    exit();
  }

  // Get the new rating for the moderated comment
  $rating = slashcomments_get_content_rating($_POST['cid']);

  // Create the string representation of the rating
  $rating_str = theme('slashcomments_rating', $rating);

  // Create the string for the message to display after moderation
  $message_str = theme('slashcomments_post_moderation_status', $result);

  // Status update for other forms on the same page
  $other_forms = theme('slashcomments_comment_moderation_status', $result['message']);

  // Set variable for the JS handler
  drupal_json(array(
    'status' => 'OK',
    'rating' => $rating_str,
    'message' => $message_str,
    'other_form_status' => $other_forms,
    'hide_forms' => !_slashcomments_user_has_mod_points($user->uid)
  ));
  exit();
}

/**
 * Submits comment without using AJAX
 */
function slashcomments_moderation_form_submit($form, &$form_state) {
  slashcomments_store_vote($form_state['values']['cid'], $form_state['values']['vote']);
}

/**
 * Stores a moderation vote
 */
function slashcomments_store_vote($cid, $vote) {
  global $user;

  $result = array();

  // load the parent node of the comment
  $nid = db_result(db_query("SELECT nid FROM {comments} WHERE cid = %d", $cid));
  if (!$nid) return;

  $node = node_load($nid);
  if (!slashcomments_node_has_slashcomments($node)) {
    return;
  }

  $author_uid = db_result(db_query("SELECT uid FROM {comments} WHERE cid=%d", $cid));

  $result['result'] = slashcomments_user_can_moderate_comment($user->uid, $cid);

  // Check if user is allowed to vote
  if ($result['result'] != USER_CAN_MODERATE) {
    return $result;
  }

  // Build vote object
  $vote  = array(
    'content_type'    => 'comment',
    'content_id'      => $cid,
    'value_type'      => 'option',
    'value'           => $vote,
    'tag'             => 'slashcomments',
  );

  // Cast the vote and recalculate score and rating for the comment
  votingapi_add_votes($vote);
  votingapi_recalculate_results('comment', $cid, TRUE);

  // update rating for the comment and subtract mod points to the moderator
  slashcomments_update_rating($cid);
  slashcomments_use_mod_point($user->uid);

  // If karma is enabled updated its value
  if (_slashcomments_karma_enabled()) {
    slashcomments_update_karma($author_uid);
    slashcomments_update_contents_karma($cid);
  }
  slashcomments_update_user_stats($author_uid);
  slashcomments_update_user_stats($user->uid);

  //$result['message'] = "Comment moderated!" . ' ';
  $result['message'] = _slashcomments_can_moderate_msg(USER_CAN_MODERATE, array('uid' => $user->uid));
  return $result;
}


/**
 * Deletes ratings for a single comment,
 *
 * It delets from the database all information slashcomments stored for the
 * comment. Karma of the author is re-caculated.
 *
 * @param $cid
 *   Comment id of the deleted comment.
 */
function slashcomments_delete_rating($cid) {
  $delete_votes = "DELETE FROM {votingapi_vote}
    WHERE content_id = %d
    AND tag = 'slashcomments'";

  db_query($delete_votes, $cid);

  $author_uid = db_result(db_query("SELECT uid FROM {slashcomments_contents_rating} WHERE content_id = %d", $cid));
  votingapi_recalculate_results('comment', $cid, TRUE);
  db_query("DELETE FROM {slashcomments_contents_rating} WHERE content_id = %d", $cid);
  db_query("DELETE FROM {slashcomments_contents_karma} WHERE content_id = %d", $cid);

  slashcomments_update_karma($author_uid);
}


/**
 * Retrieves content rating.
 *
 * Get comment score and rating for a specific content.
 * Only comments are currently supported.
 *
 * @param $cid
 *   Comment id of the comments
 *
 * @return
 *   Array containing score and rating
 *   'score' => numeric score associated to the comment
 *   'rating' => text correspoding to the most voted rating
 */
function slashcomments_get_content_rating($cid) {
  $result = array();

  if (_slashcomments_karma_enabled()) {
    $result = slashcomments_get_content_karma_rating($cid);
  }
  else {
    $result = slashcomments_get_content_plan_rating($cid);
  }
  /* If no rating information has been retrieved from the db check if it's
  author is anonymous and apply modifier to the default rating if needed */
  if (!$result) {
    $author_id = db_result(db_query("SELECT uid FROM {comments} WHERE cid = %d", $cid));
    $result['score'] = ($author_id) ? _slashcomments_get_default_score() : _slashcomments_get_default_score_anonymous();
  }
  // Avoid having an infinite score scale limiting min and max score value
  $result['score'] = slashcomments_limit_displayed_score($result['score']);

  // return score and rating
  return $result;
}

/**
 * Retrieves plan comment rating.
 *
 * Get comment score and rating for a specific content without applying any
 * modifier (i.e.: karma)
 *
 * @param $cid
 *   Comment id of the comments
 *
 * @return
 *   Array containing score and rating
 *   'score' => numeric score associated to the comment
 *   'rating' => text correspoding to the most voted rating
 */
function slashcomments_get_content_plan_rating($cid) {
  $sql = "SELECT r.score, o.rating
    FROM {slashcomments_contents_rating} r
    LEFT JOIN {slashcomments_rating_options} o
    ON r.most_rated_id = o.rating_id
    WHERE r.content_id = %d";

  return db_fetch_array(db_query($sql, $cid));
}

/**
 * Retrieves karma modified comment rating.
 *
 * Get comment score and rating for a specific content applying karma modifier
 *
 * @param $cid
 *   Comment id of the comments
 *
 * @return
 *   Array containing score and rating
 *   'score' => numeric score associated to the comment
 *   'rating' => text correspoding to the most voted rating
 */
function slashcomments_get_content_karma_rating($cid) {
  $sql = "SELECT IFNULL(k.score, r.score) score, o.rating
    FROM {slashcomments_contents_rating} r
    LEFT JOIN {slashcomments_contents_karma} k
    ON r.content_id = k.content_id
    LEFT JOIN {slashcomments_rating_options} o
    ON r.most_rated_id = o.rating_id
    WHERE r.content_id = %d";

  return db_fetch_array(db_query($sql, $cid));
}

function slashcomments_limit_displayed_score($score) {
  return ($score < SLASHCOMMENTS_LOWEST_DISPLAY_RATING) ? SLASHCOMMENTS_LOWEST_DISPLAY_RATING
    : (($score > SLASHCOMMENTS_HIGHEST_DISPLAY_RATING) ?  SLASHCOMMENTS_HIGHEST_DISPLAY_RATING : $score);
}

/**
 * Updates rating for a given content.
 *
 * Recalculate rating for a given content according to the moderation/votes it
 * received. Only comments are supported as content.
 *
 * @param $content_id
 *   The content identifier.
 */
function slashcomments_update_rating($content_id) {
  // Get the new rating for the content
  $rating = slashcomments_calculate_rating($content_id);

  // Set missing field base on the fact the content rating has already be stored
  $rating['modified'] = time();

  $exists = db_result(db_query("SELECT count(*) from {slashcomments_contents_rating} WHERE content_id = %d", $content_id));
  if ($exists) {
    $update = 'content_id';
  }
  else {
    $update = NULL;
    $rating['created'] = $rating['modified'];
  }

  // Store the rating in the DB
  $ret = drupal_write_record('slashcomments_contents_rating', $rating, $update);
}

/**
 * Sets karma information for a given content.
 *
 * When a content is submitted it's initial score depends on the user karma. If
 * this score is different from the default score it needs to be stored to be
 * used lately when the score is retrieved.
 *
 * @param $cid
 *   Content_id for the content the initial value is going to be assigned
 *
 * @param $author_uid
 *   Identifier of the user who posted the content
 */
function slashcomments_init_contents_karma($cid, $author_uid, $use_default=FALSE) {

  db_query("DELETE FROM {slashcomments_contents_karma} WHERE content_id = %d", $cid);
  // If user karma has the default value no modifier is applied
  $karma = ($use_default) ? _slashcomments_get_default_karma() :  slashcomments_get_user_karma($author_uid);
  $modifier = _slashcomments_get_karma_modifier($karma);

  // assign values to missing filed and store the info
  $record['content_id'] = $cid;
  $record['karma'] = $karma;
  $record['created'] = $record['modified'] = time();
  $record['score'] = SLASHCOMMENTS_DEFAULT_SCORE + $modifier;
  drupal_write_record('slashcomments_contents_karma', $record);
}

/**
 * Sets karma information for a given content.
 *
 * When a content is submitted it's initial score depends on the user karma. If
 * this score is different from the default score it needs to be stored to be
 * used lately when the score is retrieved.
 *
 * @param $cid
 *   Content_id for the content the initial value is going to be assigned
 *
 * @param $author_uid
 *   Identifier of the user who posted the content
 */
function slashcomments_update_contents_karma($cid) {

  $record = array();

  $sql = "SELECT r.score, km.modifier
    FROM {slashcomments_contents_rating} r,
{slashcomments_contents_karma} k,
{slashcomments_karma_modifier} km
WHERE r.content_id = k.content_id
AND k.karma BETWEEN km.karma_from AND km.karma_to
AND r.content_id = %d";

$result = db_fetch_array(db_query($sql, $cid));
$record['score'] = $result['score'] + $result['modifier'];

// assign values to missing filed and store the info
$record['content_id'] = $cid;
$record['modified'] = time();
drupal_write_record('slashcomments_contents_karma', $record, 'content_id');
}

/**
 * Gets score modifier base on karma.
 *
 * Retrieves the score modifier for a content according to the karma its author
 * had when the content has been posted.
 *
 * @param $content_id
 *   The identifier of the content
 *
 * @return
 *   An integer indicating the increase/decrease to apply to the score
 */
function _slashcomments_get_content_karma_modifier($content_id) {
  $sql = "SELECT km.modifier
    FROM {slashcomments_contents_karma} ck, {slashcomments_karma_modifier} km
    WHERE ck.karma BETWEEN km.karma_from AND km.karma_to
    AND content_id=%d";

  // Gets the modifier from the database
  $modifier = db_result(db_query($sql, $content_id));
  // Return the vale or 0 if it wasn't found
  return ($modifier) ? $modifier : 0;
}

/**
 * Gets score modifier for a given karma karma.
 *
 * @param $karma
 *   Karma value
 *
 * @return
 *   An integer indicating the increase/decrease to apply to the score
 */
function _slashcomments_get_karma_modifier($karma) {
  $sql = "SELECT km.modifier
    FROM {slashcomments_karma_modifier} km
    WHERE %d BETWEEN km.karma_from AND km.karma_to";

  // Gets the modifier from the database
  $modifier = db_result(db_query($sql, $karma));
  // Return the vale or 0 if it wasn't found
  return ($modifier) ? $modifier : 0;
}


/**
 * Calculates rating for a given content.
 *
 * @param $cid
 *   The content identifier
 *
 * @return
 *   An array with fhr following infos
 *   'content_id' => Identifier of the content
 *   'uid' => Identifier of the author
 *   'score' => Score assigned to the content
 *   'num_ratings' => Number of moderations/votes that contributed to the score
 *   'most_rated_id' => id of the moderation options that get more votes
 */
function slashcomments_calculate_rating($cid) {
  $rating = array();

  $sql = "
    SELECT  c.cid content_id, c.uid,
    IFNULL(SUM(o.score),0)  + CASE WHEN c.uid = 0 THEN %d ELSE %d  END score,
    count(v.vote_id) num_ratings,
    max(v.timestamp) last_rated
    FROM {comments} c
    LEFT JOIN {votingapi_vote} v
    ON v.content_id = c.cid
    AND v.content_type = 'comment' AND v.tag = 'slashcomments'
    LEFT JOIN {slashcomments_rating_options} o
    ON v.value = o.rating_id
    WHERE c.cid = %d
    GROUP BY v.content_id, c.uid
    ";

  // Get score info from the db
  $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(), $cid);
  $rating = db_fetch_array($result);

  // extrat most voted rating including only positive/negative
  // values depending on the score
  $rating['most_rated_id'] = '';
  $score_filter = $rating['score'] >= 1 ? ">= 0" : "< 0";

  $sql = "SELECT o.rating_id, count(*), max(v.timestamp)
    FROM {votingapi_vote} v, {slashcomments_rating_options} o
    WHERE v.value = o.rating_id
    AND v.content_type = 'comment' AND v.content_id = %d
    AND v.value_type = 'option' AND v.tag = 'slashcomments'
    AND o.score %s
    GROUP BY o.rating_id
    ORDER BY 2 DESC, 3 DESC, 1";

  $row = db_fetch_object(db_query_range($sql, $cid, $score_filter, 0, 1));

  // Add the most_rated_id and return the result
  $rating['most_rated_id'] = $row->rating_id ? $row->rating_id : -1;
  return $rating;
}

/**
 * Updates stats of a given user.
 *
 * @param $uid
 *   User identifier
 */
function slashcomments_update_user_stats($uid) {
  //if ($uid == 0) {
  //return;
  //}

  $sql = "SELECT count(*) FROM {slashcomments_users_stats} WHERE uid = %d";
  $has_stats = db_result(db_query($sql, $uid));

  // Query to extract stats on posted comments
  $sql =  "SELECT count(*) posted,
    SUM(CASE WHEN num_ratings <> 0 AND score < 1 THEN 1 ELSE 0 END) negative,
    SUM(CASE WHEN num_ratings <> 0 AND score > 1 THEN 1 ELSE 0 END) positive,
    SUM(CASE WHEN r.content_id is null OR num_ratings = 0 OR score = 1 THEN 1 ELSE 0 END) neutral
    FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
    ON c.cid = r.content_id
    WHERE c.uid = %d";

  // Extract the data
  $result = db_query($sql, $uid);
  $posted = db_fetch_array($result);

  // Query to extract stats on moderated comments
  $sql = "SELECT count(*) moderated,
    SUM(CASE WHEN score < 0 THEN 1 ELSE 0 END) moderated_negative,
    SUM(CASE WHEN score > 0 THEN 1 ELSE 0 END) moderated_positive,
    SUM(CASE WHEN score = 0 THEN 1 ELSE 0 END) moderated_neutral
    FROM {votingapi_vote} v, {slashcomments_rating_options} o
    WHERE v.value = o.rating_id
    AND content_type = 'comment' AND tag = 'slashcomments'
    AND value_type = 'option' AND uid = %d";

  // Extract the data
  $result = db_query($sql, $uid);
  $moderated = db_fetch_array($result);
  $record = (object)array_merge($posted, $moderated);

  // add missing fields
  $record->uid = $uid;
  $record->modified = time();

  if ($has_stats) {
    $update = 'uid';
  }
  else {
    $update = NULL;
    $record->created = $record->modified;
  }

  // Store the stats in the db
  drupal_write_record('slashcomments_users_stats', $record, $update);
}

/**
 * Updates karma of a given user.
 *
 * @param $uid
 *   User identifier
 */
function slashcomments_update_karma($uid) {
  if ($uid == 0) {
    return;
  }

  // min and max rating considering when karma is calculated
  $sql = "SELECT count(*) FROM {slashcomments_contents_rating} WHERE uid = %d AND num_ratings <> 0";
  $comments_num = db_result(db_query($sql, $uid));
  $comments_for_karma = _slashcomments_get_ratings_for_karma();
  $lowest_for_karma = _slashcomments_get_lowest_score_for_karma();
  $highest_for_karma = _slashcomments_get_highest_score_for_karma();
  $has_karma = slashcomments_user_has_karma($uid);

  // If moderated karma are not enough erase karma value and return
  if ($comments_num < $comments_for_karma) {
    if ($has_karma) {
      db_query("DELETE FROM {slashcomments_users_karma} WHERE uid = %d", $uid);
    }
    return;
  }

  // Query to extract karma
  $sql =  "SELECT AVG(CASE WHEN score <  %d THEN %d
    WHEN score > %d THEN %d
    ELSE score END ) karma
      FROM {slashcomments_contents_rating} r
      WHERE r.uid = %d
      AND r.num_ratings <> 0
      HAVING count(*) >= %d";

  // Extract the data and fill missing fields
  $result = db_query($sql, $lowest_for_karma, $lowest_for_karma,
    $highest_for_karma, $highest_for_karma, $uid, $comments_for_karma);
  $record = db_fetch_object($result);
  $record->uid = $uid;
  $record->modified = time();

  if ($has_karma) {
    $update = 'uid';
  }
  else {
    $update = NULL;
    $record->created = $record->modified;
  }

  // Store the new karma value in the db
  drupal_write_record('slashcomments_users_karma', $record, $update);
}

/*
 * Determines if user has karma.
 *
 * @param $uid
 *   User identifier
 *
 * @return
 *   TRUE if user has a karma value, FALSE otherwise
 */
function slashcomments_user_has_karma($uid) {
  $sql =  "SELECT count(*)
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $has_karma = db_result(db_query($sql, $uid));

  return ($has_karma) ? TRUE : FALSE;
}

/*
 * Gets the current karma value of a given user.
 *
 * @param $uid
 *   User identifier whose karma has to be retrieved
 *
 * @return
 *   Current karma value for the user
 */
function slashcomments_get_user_karma($uid) {
  //return NULL;
  $sql =  "SELECT karma
    FROM {slashcomments_users_karma}
    WHERE uid = %d";

  $karma = db_result(db_query($sql, $uid));

  if ($karma === FALSE OR $karma === NULL) {
    $karma = _slashcomments_get_default_karma();
  }
  return $karma;
}

/*
 * Gets karma value to display.
 *
 * Gets the karma values to display on user profile and comments. The value can
 * be different from the real karma has the displayed scale is smaller.
 *
 * @param $uid
 *   User identifier whose karma has to be retrieved
 *
 * @return
 *   Karma value to display
 */
function slashcomments_get_user_display_karma($uid) {
  $karma = slashcomments_get_user_karma($uid);
  $display_karma = slashcomments_limit_displayed_score($karma);
  return $display_karma;
}


/**
 * Implementation of hook_form_alter().
 *
 * Modify comment settings form (available for each content type) and comment
 * controls displayed, if enabled, above and below comments.
 */
function slashcomments_form_alter(&$form, $form_state, $form_id) {

  $node = $form['#node_type'];
  if (!$node) {
    $node = node_load(arg(1));
  }

  if (!slashcomments_node_has_slashcomments($node)) {
    return;
  }

  if ($form_id == 'comment_form') {
    unset($form['comment_filter']['comment']['#title']);
  }

  // Add threshold option and override display mode option in the content type
  // settings page.
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {

    $form['comment']['comment_default_threshold'] = array(
      '#type' => 'select',
      '#title' => t('Default comments threshold'),
      '#default_value' => variable_get('comment_default_threshold_'. $form['#node_type']->type, SLASHCOMMENTS_DEFAULT_THRESHOLD),
      '#options' => _slashcomments_thresholds(),
      '#description' => t('Default threshold for comments. Comments with lower score will be collapsed.'),
      '#weight' => -5,
    );
    $form['comment']['comment_default_mode'] = array(
      '#type' => 'select',
      '#title' => t('Default display mode'),
      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, SLASHCOMMENTS_MODE_FLAT),
      '#options' => _slashcomments_modes(),
      '#description' => t('The default view for comments.'),
      '#weight' => -4,
    );
    $form['comment']['comment_default_per_page']['#weight'] = -3;

    //order is always oldest first
    unset($form['comment']['comment_default_order']);
  }

  // Add threshold option and override display mode option to comment controls form
  if ($form_id == 'comment_controls') {
    // WARNING: we cannot get node type from form info, so, we have to load from arg(1)
    $node = node_load(arg(1));

    $form['threshold'] = array(
      '#type' => 'select',
      '#title' => t('Threshold'),
      '#options' => _slashcomments_thresholds($node),
      '#default_value' => _slashcomments_get_display_setting('threshold', $node),
      '#weight' => 0,
    );

    $form['mode'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('mode', $node),
      '#options' => _slashcomments_modes(),
      '#weight' => 1,
    );

    //order is always oldest first
    $form['order'] = array(
      '#type' => 'hidden',
      '#value' => COMMENT_ORDER_OLDEST_FIRST,
    );

    $form['comments_per_page'] = array(
      '#type' => 'select',
      '#default_value' => _slashcomments_get_display_setting('comments_per_page', $node),
      '#options' => _slashcomments_per_page(),
      '#weight' => 3,
    );

    $form['#submit'][] = 'slashcomments_comment_control_submit';
  }
}

/**
 * Submit callback for comments control (threshold, mode, per page)
 */
function slashcomments_comment_control_submit($form, &$form_state) {
  global $user;
  $threshold = $form_state['values']['threshold'];
  $mode = $form_state['values']['mode'];
  $order = $form_state['values']['order'];
  $comments_per_page = $form_state['values']['comments_per_page'];

  if ($user->uid) {
    $account = user_save($user, array('threshold' => $threshold, 'mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }
  }

  $_SESSION['comment_threshold'] = $threshold;
  $_SESSION['comment_mode'] = $mode;
  $_SESSION['comment_sort'] = $order;
  $_SESSION['comment_comments_per_page'] = $comments_per_page;
}


/**
 * FAPI definition for the comment moderation form.
 *
 * @ingroup forms
 * @see slashcomments_moderation_form_submit()
 */
function slashcomments_moderation_form($form_state, $cid, $uid) {
  $form['cid'] = array('#type' => 'hidden', '#default_value' => $cid);
  $form['uid'] = array('#type' => 'hidden', '#default_value' => $uid);

  $form['vote'] = array(
    '#title' => '',
    '#type' => 'select',
    '#options' => _slashcomments_moderation_options(),
    '#default_value' => 0,
    '#weight' => 30
  );


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Moderate'),
    '#weight' => 50
  );

  $form['#submit'][] = 'slashcomments_moderation_form_submit';

  return $form;
}


/**
 * Implementation of hook_user().
 */
function slashcomments_user($op, &$edit, &$account, $category = 'account') {
  global $user;

  switch ($op) {
  case 'view':
    if (_slashcomments_karma_enabled()) {
      $user_karma = slashcomments_get_user_display_karma($account->uid);

    }
    if ($user->uid == $account->uid || $user->uid == 1 || user_access('administer slashcomments')) {
      if (_slashcomments_get_mod_per_day() != SLASHCOMMENTS_INFINITE_MOD_POINTS) {
        $mod_points = slashcomments_get_user_mod_points($account->uid);

        if ($mod_pints == SLASHCOMMENTS_INFINITE_MOD_POINTS) {
          $mod_points = t('Infinite');
        }
      }

      $can_vote = slashcomments_user_can_moderate($user->uid);

      $msg_attrib = array('uid' => $user->uid);
      $msg_filter = array(IS_NEWBIE, LOW_KARMA);

      $messages = _slashcomments_can_moderate_msg($can_vote, $msg_attrib, $msg_filter);
    }

    if (isset($user_karma) || isset($mod_points) || count($messages)) {
      $account->content['slashcomments'] = array(
        '#type' => 'user_profile_category',
        '#title' => t('Comment Moderations'),
        '#weight' => 10,
      );
    }

    if (isset($user_karma)) {
      $account->content['slashcomments']['karma'] = array(
        '#title' => t('Karma value'),
        '#type' => 'user_profile_item',
        '#value' => $user_karma,
        '#weight' => 1,
      );
    }

    if (isset($mod_points)) {
      $account->content['slashcomments']['mod_points'] = array(
        '#title' => t('Moderation points'),
        '#type' => 'user_profile_item',
        '#value' => $mod_points,
        '#weight' => 2,
      );
    }

    if (count($messages)) {
      $account->content['slashcomments']['mod_points'] = array(
        '#title' => t('Moderation status'),
        '#type' => 'user_profile_item',
        '#value' => theme('slashcomments_comment_moderation_status', $messages),
        '#weight' => 2,
      );
    }

    break;
  case 'delete':
    delete_slashcomments_user_data($account->uid);
    break;
  }
}

/**
 * Get html code to display user notifications.
 *
 * @param $uid
 *   User identifier currently browsing the site
 *
 * @param $type
 *   Type of notification to be shown
 *   TODO There's only one type of notification right now
 *
 * @return
 *   HTML to display for the notification
 */
function slashcomments_get_user_notifications($uid, $type) {

  // keep track of the first call so that the code is not re-executed
  static $first = TRUE;

  // if it's not the first call generate the notification code
  if ($first) {

    $sql = "SELECT sunid, display_times FROM {slashcomments_users_notifications} WHERE uid = %d and ntype_id = %d and display_times > 0";
    $notification = db_fetch_array(db_query($sql, $uid, 1));

    if ($notification) {

      $help_page = _slashcomments_get_help_page_path();
      $title = t("Modation points");
      $body = t("Great! You've just received some moderations points.") . "<br/>";
      $body .= t("As it looks like it's your first time you should check");
      $body .= '<a href="' . url($help_page) . '"> ' . t("the help page") . ' </a>';
      $body .= t("to know more about the moderation system.");
      $first = FALSE;

      slashcommets_update_notification_display_times($notification['sunid'], $notification['display_times']-1);

      return theme('slashcomments_notification', $title, $body);
    }
  }
  return '';
}


/**
 * Update the number of time a notification need to be displayed.
 *
 * @param $sunid
 *   Notification identifier
 *
 * @param $type
 *   Number of times the notification need to be displayed
 *
 * @return
 *   NULL
 */
function slashcommets_update_notification_display_times($sunid, $times) {
  $record = array();
  $record['display_times'] = $times;
  $record['modified'] = $record['created'] = time();
  $record['sunid'] = $sunid;
  $update = 'sunid';
  drupal_write_record('slashcomments_users_notifications', $record, $update);
}

/**
 * Dismiss notifications for the user.
 * TODO The functions should take a notification type but as there's only one
 * it doesn't really matter right now.
 */
function slashcomments_dismiss_notification() {
  global $user;

  $sql = "SELECT sunid FROM {slashcomments_users_notifications} WHERE uid = %d and ntype_id = %d";
  $notification = db_fetch_array(db_query($sql, $user->uid, 1));

  if ($notification) {
    slashcommets_update_notification_display_times($notification['sunid'], 0);
  }
}

/**
 * Implementation of hook_preprocess_comment().
 *
 * Preprocesses template variables for the comment template. Adds comments
 * rating information, moderation form and class for collapsed/expanded comments
 * depending on the threshold.
 */
function slashcomments_preprocess_comment(&$variables) {


  if (!slashcomments_node_has_slashcomments($variables['node'])) {
    return;
  }

  global $user, $_slashcomments_ignore_threshold;

  $comment = $variables['comment'];
  if (!$comment->cid) {
    return;
  }

  // set the proper template to display comments
  _slashcomments_set_comment_template($variables);
  // get score and rating
  $rating = slashcomments_get_content_rating($comment->cid);
  $variables['slashcomments_rating'] = theme('slashcomments_rating', $rating);

  $reply = arg(0) == 'comment' && (arg(1) == 'reply' || arg(1) == 'edit');
  $can_vote = slashcomments_user_can_moderate_comment($user->uid, $comment->cid);

  // get default threshold for the content type
  $threshold = ($_slashcomments_ignore_threshold) ? -1 : _slashcomments_get_display_setting('threshold', $variables['node']);

  // fill out template variable used as css classes to display different kind of
  // comments: collapsed, expanded, own
  if ($rating['score'] >= $threshold) {
    $variables['collapsed'] = '';
    $variables['toggle_label'] = 'non_toggle_label';
    $variables['toggle_area'] = 'non_toggle_area';

    // Show moderation form if the user can moderate and is not on the edit or reply page
    //if (!$reply && $can_vote['result'] == 1) {
    if (!$reply) {
      $msg_attrib = array('uid' => $user->uid, 'cid' => $comment->cid);

      if ($can_vote == USER_CAN_MODERATE) {
        $msg_filter = array(USER_CAN_MODERATE);
        $show_form = TRUE;
      }
      else {
        $msg_filter = array(ALREADY_MODERATED, OWN_COMMENT);
        $show_form = FALSE;
      }

      $messages = _slashcomments_can_moderate_msg($can_vote, $msg_attrib, $msg_filter);
      $variables['slashcomments_form'] = theme('slashcomments_form_wrapper', $comment->cid, $comment->uid, $show_form, $messages);

      $variables['slashcomments_form'] .= slashcomments_get_user_notifications($user->uid, 'new_mod_points');
    }

    // add karma if it's enabled
    if (_slashcomments_karma_enabled()) {
      $variables['slashcomments_karma'] = theme('slashcomments_karma', slashcomments_get_user_display_karma($comment->uid));
    }
  }
  else {
    $variables['collapsed'] = 'collapsed';
    $variables['toggle_label'] = 'toggle_label';
    $variables['toggle_area'] = 'toggle_area';
  }
  $variables['toggle_label'] .= ' ' . $comment->own;
  $variables['toggle_area'] .= ' ' . $comment->own;

  // generate permalink
  $page_number = $_GET['page'];

  if (!$page_number) {
    $page_number = 0;
  }

  $fragment = 'comment-' . $variables['comment']->cid;
  $query = ($page_number) ? 'page=' . $page_number : NULL;
  $img_path = _slashcomments_get_image_path();
  $linktext = '<img src="' . $img_path . '/permalink.gif" />';
  $linkpath = 'node/' . $variables['node']->nid;
  $variables['comment_link'] = l($linktext, $linkpath, array('query' => $query, 'fragment' => $fragment, 'html' => TRUE));

  // Link to page created by Comment Page module, if it exists
  $variables['page_link'] = '';
  if (!empty($variables['comment']->page_url) && !(arg(0) == 'comment' && arg(1) == $variables['comment']->cid)) {
    $variables['page_link'] = l(t('(permalink)'), $variables['comment']->page_url);
  }
}

/**
 * Overrides theme_comment_view()
 */
function slashcomments_comment_view($comment, $node, $links = array(), $visible = TRUE) {
  static $first_new = TRUE;
  $output = '';
  $comment->new = node_mark($comment->nid, $comment->timestamp);
  if ($first_new && $comment->new != MARK_READ) {
    // Assign the anchor only for the first new comment. This avoids duplicate
    // id attributes on a page.
    $first_new = FALSE;
    $output .= "<a id=\"new\"></a>\n";
  }

  //$output .= "<a id=\"comment-$comment->cid\"></a>\n";
  $comment->comment = check_markup($comment->comment, $comment->format, FALSE);

  // Comment API hook
  comment_invoke_comment($comment, 'view');
  $output .= theme('comment', $comment, $node, $links);
  return $output;
}

/**
 * Implementation of hook_comment().
 */
function slashcomments_comment($comment, $op) {
  switch ($op) {
  case 'view':
    global $user;

    // marke comments of the user in order to theme them differently
    if ($user->uid == $comment->uid && $user->uid != 0) {
      $comment->own = "own";
    }
    break;
  case 'insert':

    slashcomments_update_rating($cid);

    // if karma is enable apply a modifier to the initial comment rating
    if (_slashcomments_karma_enabled()) {
      slashcomments_init_contents_karma($comment['cid'], $comment['uid']);
    }
    slashcomments_update_user_stats($comment['uid']);
    break;
  case 'delete':
    // Delete slashcomments data stored for the comment
    slashcomments_delete_rating($comment->cid);
    slashcomments_update_user_stats($comment->cid);
    break;
  }
}


/**
 * Implementation of hook_preprocess_author_pane().
 */
function slashcomments_preprocess_author_pane(&$variables) {
  $node = node_load($variables['context']->nid);
  if (!slashcomments_node_has_slashcomments($node)) {
    return;
  }

  _slashcomments_set_author_pane_template($variables);

  // Add karma to template variables
  if (_slashcomments_karma_enabled()) {
    $variables['slashcomments_karma'] = slashcomments_get_user_display_karma($variables['account']->uid);
  }
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function slashcomments_theme_registry_alter($theme_registry) {
  // replace the theme function for comment_view */
  if (!empty($theme_registry['comment_view'])) {
    $theme_registry['comment_view']['function'] = 'slashcomments_comment_view';
  }

  // replace the theme function for collapsed view with expanded view */
  if (!empty($theme_registry['comment_flat_collapsed'])) {
    $theme_registry['comment_flat_collapsed']['function'] = 'theme_comment_flat_expanded';
  }
  if (!empty($theme_registry['comment_thread_collapsed'])) {
    $theme_registry['comment_thread_collapsed']['function'] = 'theme_comment_thread_expanded';
  }

  // Code ported from the advanced forum module
  // --- The following section manipulates the theme registry so the .tpl files
  // --- for the given templates can be found first in the (sub)theme directory
  // --- then in ancestor themes, if any, and finally in the slashcomments folder.

  // Affected templates
  $templates = array('comment', 'author_pane');

  // Find all our ancestor themes and put them in an array.
  global $theme;
  $themes = list_themes();

  $ancestor_paths = array();
  $ancestor = $theme;
  while ($ancestor && isset($themes[$ancestor]->base_theme)) {
    array_unshift($ancestor_paths, dirname($themes[$themes[$ancestor]->base_theme]->filename));
    $ancestor = $themes[$ancestor]->base_theme;
  }
  $module_path = drupal_get_path('module', 'slashcomments') . '/templates';

  foreach ($templates as $template) {
    // Sanity check in case the template is not being used.
    if (is_array($theme_registry[$template])) {
      // If there was a path in there, store it.
      $existing_path = array_shift($theme_registry[$template]['theme paths']);
      array_unshift($theme_registry[$template]['theme paths'], $existing_path, $module_path);

      // If there are any ancestor paths (ie: we are in a subtheme, add those)
      foreach ($ancestor_paths as $ancestor_path) {
        $theme_registry[$template]['theme paths'][] = $ancestor_path;
      }
      //Put the active theme's path last since that takes precidence.
      $theme_registry[$template]['theme paths'][] = path_to_theme();
    }
  }
}

/*
 * Themes the status message displayed when a message is moderated
 *
 * @parma $result
 *  Array with the status and message to display
 *    'result => "ok" or "error" according to the moderation result
 *    'message' => message displayed to the user
 *
 * @return
 *  HTML for the message to display after moderation
 */
function theme_slashcomments_post_moderation_status($result) {
  $class = ($result['result']) ? 'ok' : 'error';
  $output = '<div class="messages ' . $class . '">';
  $output .= ($result['result']) ? t('Comment moderated!') . ' ' : '';
  $output .= implode("\n", $result['message']);
  $output .= '</div>';

  return $output;
}

/*
 * Themes the status message displayed under or instead of the moderation forum
 *
 * @parma $result
 * Array with the list of messages tp display
 *
 * @return
 *  HTML for the messages to display
 */
function theme_slashcomments_comment_moderation_status($messages) {
  //$output = '<div class="slashcomments-comment-moderation-status">';
  $output .= implode("<br/>", $messages);
  //$output .= '</div>';

  return $output;
}

/**
 * Themes slashcomments_rating and score.
 *
 * Themes the rating, score and help button displayed on each comment header
 *
 * @param $rating
 *  Array with rating information:
 *    'rating' => Text description of the most voted rating
 *    'score' => Score for the comment
 *
 * @return
 *  HTML for the rating, score and help button
 */
function theme_slashcomments_rating($rating) {
  $icon_url = _slashcomments_get_image_path() . '/question_mark.png';
  $icon_url_2 = _slashcomments_get_image_path() . '/forbidden.png';
  $help_page = _slashcomments_get_help_page_path();

  $output = '<span class="scomments_rating">';
  $output .= '(' . t('Score') . ': ' . $rating['score'];
  $output .= ($rating['rating']) ? ' ' . $rating['rating'] : '';
  $output .= ($help_page) ? '<a alt="What is this?" title="What is this?" href="' . url($help_page) . '"><img class="help_icon" src="'. $icon_url .'" /></a>' : '';
  //$output .= '<a alt="What is this?" title="What is this?" href="' . $help_page . '"><img class="help_icon" src="'. $icon_url_2 .'" /></a>';
  $output .= ')';
  $output .= '</span>';

  return $output;
}


/*
 * Themes karma
 *
 * @parma $karma
 *   Karma value
 *
 * @return
 *   HTML to display karma
 */
function theme_slashcomments_karma($karma) {
  return '<p class="slashcomments-karma">' . t('Karma') . ': ' . $karma . '</p>';
}


/**
 * Themes the moderation form.
 *
 * Themes the form container and the form used to moderated comments.
 *
 * @param $cid
 *   Comment id of the comment the form will moderate
 *
 * @param $uid
 *   User id of the user displaying the page
 *
 * @param $message
 *   Status message to display below the form (not currently used)
 *
 * @return
 *   -HTML to display the form to moderate comments
 */
function theme_slashcomments_form_wrapper($cid, $uid, $show_form = TRUE,  $messages = '') {
  $msg_class = '';
  $output =  '<div id="slashcomments-form-wrapper-' . $cid . '" class="scomments_container">';
  $output .= '<div class="container-inline">';

  if ($show_form) {
    $output .= '<div class="scomments_form">' .  drupal_get_form('slashcomments_moderation_form', $cid, $uid) . '</div>';
    $msg_class = 'slashcomments-with-form';
  }

  $output .= '<div class="scomments_loader"></div>';
  $output .= '<div class="slashcomments-comment-moderation-status ' . $msg_class . '">';
  $output .= theme('slashcomments_comment_moderation_status', $messages);
  $output .= '</div>';
  $output .= '</div></div>';
  return $output;
}

/**
 * Gets the template file to use for comments.
 *
 * Return the proper template to use for theming comments. It handle the
 * presence of standard comments and advanced forum (v1.0 and v2.0).
 *
 * @param $used_tpl_file
 *   The name of the template file read from the theme registry.
 *
 * @return
 *   The name of the template to use.
 */
function _slashcomments_get_comment_template($used_tpl_file) {

  $tpl_files = array(
    "advf-forum-post"       => "slashcomments-advf-post-1x",
    "advanced_forum.post"   => "slashcomments-advf-post-2x"
  );

  return ($tpl_files[$used_tpl_file]) ? $tpl_files[$used_tpl_file] : "slashcomments-comment";
}


/*
 * Retrieves the right template for comments and set it.
 *
 * @param $variables
 *  Variables preprocessed by comment preprocess function
 *
 * @return
 *  NULL
 */
function _slashcomments_set_comment_template(&$variables) {
  static $new_tpl_file; // keep the template in case multiple calls

  if (empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_comment_template($used_tpl_file);
    _slashcomments_add_comment_template_files($new_tpl_file);
  }
  $variables['template_files'][] = $new_tpl_file;
}

/* Includes external files (javascript and stylesheets
 * needed for the chosen template.
 *
 * @param $new_tpl_file
 *   The template file that is going to be used for displaying comments
 *
 * @return
 *   NULL
 */
function _slashcomments_add_comment_template_files($new_tpl_file) {

  global $user;

  // add base url and other needed js variables
  drupal_add_js(
    array(
      'baseUrl'  => url($GLOBALS['base_url']),
      'slashcomments' => array('error_status' => t("Error moderationg comment"),
      'load_image_path' => _slashcomments_get_image_path() . '/loading.gif',
      'uid' => $user->uid)
    ),
    'setting'
  );

  drupal_add_js(drupal_get_path('module', 'slashcomments') .'/scripts/slashcomments.js');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/slashcomments.css');
  drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
}


/**
 * Gets the template file to use for the author pane.
 *
 * Gets the proper template to use based on the fact advanced form is present
 * and the fact author pane is in stacked mode.
 *
 * @param $used_tpl_file
 *   Template file currently in use.
 *
 * @return
 *   Template file that is going to be used.
 */
function _slashcomments_get_author_pane_template($used_tpl_file) {

  $tpl_files = array(
    "advf-author-pane"                    => "slashcomments-advf-author-pane-1x",
    "advf-author-pane-stacked"             => "slashcomments-advf-author-pane-stacked-1x",
    "advanced_forum.author-pane"          => "slashcomments-advf-author-pane-2x",
    "advanced_forum.author-pane-stacked"  => "slashcomments-advf-author-pane-stacked-2x",
    "author-pane"                         => "slashcomments-author-pane"
  );

  // Replace the template file with the version provided by slashcomments
  if (module_exists("advanced_forum") && strpos(advanced_forum_get_current_style(), 'stacked')) {
    $used_tpl_file .= "-stacked";
  }
  return $tpl_files[$used_tpl_file];
}

/*
 * Retrieves the right template for author_pane and set it.
 *
 * @param $variables
 *   Variables processed by author_pane preprocess functions.
 */
function _slashcomments_set_author_pane_template(&$variables) {
  static $new_tpl_file;

  if (empty($new_tpl_file)) {
    // get current tpl_file
    $used_tpl_file = $variables['template_files'][count($variables['template_files'])-1];

    // Replace the template file with the version provided by slashcomments
    $new_tpl_file = _slashcomments_get_author_pane_template($used_tpl_file);
    drupal_add_css(drupal_get_path('module', 'slashcomments') .'/styles/' . $new_tpl_file . '.css');
  }
  $variables['template_files'][] = $new_tpl_file;
}

/**
 * Get available ratings
 *
 * @return
 *  Array of available ratings. Array keys are rating id and values are
 *  ratings descriptions
 */
function _slashcomments_moderation_options() {
  static $rating_options;

  // query the database only once for each request
  if (!$rating_options) {
    /* extract enabled ratings from the db */
    $sql = "SELECT rating_id, rating
      FROM {slashcomments_rating_options}
      WHERE enabled = 1
      ORDER BY weight
      ";

    $db_ratings = db_query($sql);

    $rating_options = array();
    while ($rating = db_fetch_object($db_ratings)) {
      $rating_options[$rating->rating_id] = $rating->rating;
    }
  }
  return $rating_options;
}

/*
 * Retrieves thresholds for node and settings.
 *
 * @node
 *  Node being displayed. Used to calculate how many comments will be
 *  displayed for each selected threshold
 *
 * @retunrn
 *  Array of available options to be used in a drop-down list
 */
function _slashcomments_thresholds($node = NULL) {

  // Possible threshold value
  $thresholds = array(-1, 1, 2, 3 , 4, 5);
  $options = array();

  if (!$node) {
    // if node isn't passed to the function we're in the seetings panel
    // for the content type no need to calculate the number of comments
    foreach ($thresholds as $i) {
      $options[$i] = t('Threshold: !n', array('!n' => sprintf("%+d", $i)));
    }
  }
  else {
    $comments_per_rating = array();
    foreach ($thresholds as $i) {
      $comments_per_rating[$i] = 0;
    }

    $rating_field = 'score';
    if (_slashcomments_karma_enabled()) {
      $sql = "
        SELECT score, count(*) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END)+IFNULL(m.modifier, 0) score
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          LEFT JOIN {slashcomments_contents_karma} k
          ON c.cid = k.content_id
          LEFT JOIN {slashcomments_karma_modifier} m
          ON k.karma >= m.karma_from AND k.karma <= m.karma_to
          WHERE c.nid = %d
        ) a
        GROUP BY score";
    }
    else {
      $sql = "SELECT score, count(*) num
        FROM (
          SELECT IFNULL(r.score, CASE WHEN c.uid = 0 THEN %d ELSE %d END) score
          FROM {comments} c LEFT JOIN {slashcomments_contents_rating} r
          ON c.cid = r.content_id
          WHERE c.nid = %d
        ) a
        GROUP BY score";
    }

    $result = db_query($sql, _slashcomments_get_default_score_anonymous(), _slashcomments_get_default_score(),  $node->nid);

    while ($data = db_fetch_object($result)) {
      $comments_per_rating[$data->score] = $data->num;
    }
    $comments_per_rating[-1] = $node->comment_count;

    for ($i = 6; $i>0; $i--) {
      $comments_per_rating[$i - 1] = $comments_per_rating[$i - 1] + $comments_per_rating[$i];
    }
    foreach ($thresholds as $i) {
      $options[$i] = t('!n: !s comments', array('!n' => sprintf("%+d", $i), '!s' => $comments_per_rating[$i]));
    }
  }
  return $options;
}

/*
 * Gets available options for displayng comments.
 *
 * @return
 *  Array of available options
 */
function _slashcomments_modes() {
  return array(
    SLASHCOMMENTS_MODE_FLAT => t('Display: flat'),
    SLASHCOMMENTS_MODE_THREADED => t('Display: threaded'),
  );
}

/*
 * Gets available options for number of comments to show in each page
 *
 * @return
 *  Arrays of available options
 */
function _slashcomments_per_page() {
  $per_page = array(10, 30, 50, 70, 90, 150, 200, 250, 300, 1000);
  $options = array();
  foreach ($per_page as $i) {
    $options[$i] = t('!a per page', array('!a' => $i));
  }
  return $options;
}

/**
 * Gets display settings for a given content
 */
function _slashcomments_get_display_setting($setting, $node) {
  global $user;

  if (isset($_GET[$setting])) {
    $value = $_GET[$setting];
  }
  else {
    // get the setting's site default
    switch ($setting) {
    case 'threshold':
      $default = variable_get('comment_default_threshold_'. $node->type, SLASHCOMMENTS_DEFAULT_THRESHOLD);
      break;
    case 'mode':
      $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);
      break;
    case 'sort':
      $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_OLDEST_FIRST);
      break;
    case 'comments_per_page':
      $default = variable_get('comment_default_per_page_'. $node->type, 50);
    }
    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {
      // if comment controls are disabled use site default
      $value = $default;
    }
    else {
      // otherwise use the user's setting if set
      if (isset($user->$setting) && $user->$setting) {
        $value = $user->$setting;
      }
      elseif (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {
        $value = $_SESSION['comment_'. $setting];
      }
      else {
        $value = $default;
      }
    }
  }
  return $value;
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_newbie() {
  return variable_get('slashcomments_limit_newbie', SLASHCOMMENTS_LIMIT_NEWBIE);
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_karma() {
  return variable_get('slashcomments_limit_karma', SLASHCOMMENTS_LIMIT_KARMA);
}

/* Gets values of the limit_newbie settings variable */
function _slashcomments_get_limit_takepart() {
  return variable_get('slashcomments_limit_takepart', SLASHCOMMENTS_LIMIT_TAKEPART);
}

/* Gets values of the default_score settings variable */
function _slashcomments_get_default_score() {
  return variable_get('slashcomments_default_score', SLASHCOMMENTS_DEFAULT_SCORE);
}

/* Gets values of the default_score_anonymous settings variable */
function _slashcomments_get_default_score_anonymous() {
  return variable_get('slashcomments_default_score_anonymous', SLASHCOMMENTS_DEFAULT_SCORE_ANONYMOUS);
}

/* Gets values of the default_karma settings variable */
function _slashcomments_get_default_karma() {
  return variable_get('slashcomments_default_karma', SLASHCOMMENTS_DEFAULT_KARMA);
}

/* Gets values of the rating_for_karma settings variable */
function _slashcomments_get_ratings_for_karma() {
  return variable_get('slashcomments_ratings_for_karma', SLASHCOMMENTS_RATINGS_FOR_KARMA);
}

/* Gets values of the mod_per_day settings variable */
function _slashcomments_get_mod_per_day() {
  return variable_get('slashcomments_mod_per_day', SLASHCOMMENTS_MOD_PER_DAY);
}

/* Gets values of the help_page_path settings variable */
function _slashcomments_get_help_page_path() {
  $help_page = variable_get('slashcomments_help_page_path', SLASHCOMMENTS_HELP_PAGE_PATH);
  return ($help_page == '') ? SLASHCOMMENTS_HELP_PAGE_PATH : $help_page;
}

/* Gets values of the lowest rating for karma settings variable */
function _slashcomments_get_lowest_score_for_karma() {
  return variable_get('slashcomments_lowest_score_for_karma', SLASHCOMMENTS_LOWEST_SCORE_FOR_KARMA);
}

/* Gets values of the highest rating for karma settings variable */
function _slashcomments_get_highest_score_for_karma() {
  return variable_get('slashcomments_highest_score_for_karma', SLASHCOMMENTS_HIGHEST_SCORE_FOR_KARMA);
}

/* Getss value of the enable karma variables */
function _slashcomments_karma_enabled() {
  return variable_get('slashcomments_enable_karma', SLASHCOMMENTS_ENABLE_KARMA) == 1;
}

/* Gets the url of slashcomments images folder */
function _slashcomments_get_image_path() {
  static $image_path;
  if (!$image_path) {
    $image_path = $GLOBALS['base_url'] . '/' . drupal_get_path('module', 'slashcomments') . '/images';
  }
  return $image_path;
}

/*
 * Gets moderation point for aq given user
 *
 * @param $uid
 *  Identifier of the user we're retrieving points for
 *
 * @return
 *  Number of moderation points left. It returns
 *  SLASH_COMMENTS_INFINITE_MOD_POINTS for user with the 'bypass moderation
 *  restriciton' permission
 */
function slashcomments_get_user_mod_points($uid) {

  // Infinite moderation if user bypass restriction or if it's been set that way
  if (user_access('bypass moderation restriction') || $uid == 1
    || _slashcomments_get_mod_per_day() == SLASHCOMMENTS_INFINITE_MOD_POINTS) {
      return SLASHCOMMENTS_INFINITE_MOD_POINTS;
    }

  // Gets user mod points from the db
  $sql = "SELECT uid, points, assigned
    FROM {slashcomments_users_mod_points}
    WHERE uid = %d";


  $data = db_fetch_array(db_query($sql, $uid));

  if (!$data) {
    // If user has no points yet assing them
    $points = slashcomments_assign_user_mod_points($uid, 1);
  }
  elseif (time() - $data['assigned'] > (60*60*24)) {
    // If needed time has passed assign new points to the user
    $points =  slashcomments_assign_user_mod_points($uid, 0);
  }
  else {
    // otherwise return points stored
    $points = $data['points'];
  }

  return $points;
}

/*
 * Assign moderation points to a given user
 *
 * @param $uid
 *  Identifier of the user points will be assigned
 *
 * @paran $new
 *  1 if the user has never been assigned points
 *  0 if the user has being assigned points before
 *
 * @return
 *  Number of points assigned
 */
function slashcomments_assign_user_mod_points($uid, $new = -1) {
  if ($new == -1) {
    $new = !db_result(db_query("SELECT count(*) FROM {slashcomments_users_mod_points} WHERE uid = %d", $uid));
  }
  $record['uid'] = $uid;
  $record['points'] = _slashcomments_get_mod_per_day();
  $record['modified'] = $record['assigned'] = time();
  if ($new) {
    $record['created'] = $record['modified'];
  }
  else {
    $update = 'uid';
  }
  drupal_write_record('slashcomments_users_mod_points', $record, $update);
  if ($new) {
    slashcomments_insert_notification($uid, 1);
  }
  return slashcomments_get_user_mod_points($uid);
}

/**
 * Update the number of time a notification need to be displayed.
 *
 * @param $uid
 *   User identifier
 *
 * @param $ntype_id
 *   Notification type id.
 *   TODO this is currently ignored as there's only one type of notification
 *
 * @return
 *   NULL
 */
function slashcomments_insert_notification($uid, $ntype_id) {

  $sql = "SELECT sunid, display_times FROM {slashcomments_users_notifications} WHERE uid = %d and ntype_id = %d";
  $notification = db_fetch_array(db_query($sql, $uid, 1));
  $record = array();
  $record['uid'] = $uid;
  $record['ntype_id'] = 1;
  $record['display_times'] = 3;
  $record['modified'] = $record['created'] = time();

  if ($notification) {
    $record['created'] = $record['modified'];
  }
  else {
    $record['sunid'] = $notification['sunid'];
    $update = 'sunid';
  }
  drupal_write_record('slashcomments_users_notifications', $record);
}


/*
 * Checks if user has moderation points left
 *
 * @return
 *  TRUE or FALSE depending or wheter the user has points left
 */
function _slashcomments_user_has_mod_points($uid) {
  $points = slashcomments_get_user_mod_points($uid);
  return ($points > 0 || $points == SLASHCOMMENTS_INFINITE_MOD_POINTS) ? TRUE : FALSE;
}

/*
 * Consume a moderation point.
 *
 * @param $uid
 *  Identifier of the user
 */
function slashcomments_use_mod_point($uid) {
  if (user_access('bypass moderation restriction') || $uid == 1) {
    return;
  }

  $sql = "UPDATE {slashcomments_users_mod_points}
    SET points = CASE WHEN points = 0 THEN 0 ELSE points-1 END
    WHERE uid = %d";

  db_query($sql, $uid);
}

/*
 * Get moderation strings according to the result of moderationn
 *
 * @param $code
 *  Result code of the moderation has returned from the can_moderate funtion
 *
 * @parma $uid
 *  Identifier of the user the message has been displayed to
 *
 * @return
 *  Text message related to user status regarding moderation
 */
function _slashcomments_can_moderate_msg($status, $attrib = array(), $filter = array()) {
  global $user;

  $message = '';
  $messages = array();
  $uid = $attrib['uid'];
  $cid = $attrib['cid'];

  if ($status & NO_MOD_PERMISSION) {
    $messages[NO_MOD_PERMISSION] = t("You don't have permission to moderate comments.");
  }

  if ($status & IS_NEWBIE) {
    $time_str = slashcomments_get_time_str($user->created - strtotime("-" . _slashcomments_get_limit_newbie() . " day"));
    $messages[IS_NEWBIE] = t("Being a new user you have to wait !timeleft before you can moderate.",
      array("!timeleft" => $time_str));
  }

  if ($status & LOW_KARMA) {
    $messages[LOW_KARMA] = t("You need a karma value of !karma before you can moderate comments.",
      array('!karma' => _slashcomments_get_limit_karma()));
  }

  if ($status & NO_MOD_POINTS) {
    $assigned = db_result(db_query("SELECT assigned FROM {slashcomments_users_mod_points} WHERE uid = %d", $uid));

    $time_str = slashcomments_get_time_str(60*60*24 - (time() - $assigned));
    $messages[NO_MOD_POINTS] = t("You don't have any moderation point. You'll get more in !timeleft.",
      array("!timeleft" => $time_str));
  }

  if ($status & USER_IS_NODE_AUTHOR) {
    $messages[USER_IS_NODE_AUTHOR] = t("You can't moderate comments on your own content.");
  }

  if ($status & ALREADY_MODERATED) {
    $vote = votingapi_select_votes(array('content_type' => 'comment',
      'content_id' => $cid, 'uid' => $uid, 'tag' => 'slashcomments'));

    $sql = "SELECT rating FROM {slashcomments_rating_options} WHERE rating_id = %d";
    $rating = db_result(db_query($sql, $vote[0]['value']));
    $messages[ALREADY_MODERATED] = t("You have already moderated this comment as " . $rating . ".");
  }

  if ($status & TOOK_PART) {
    $messages[TOOK_PART] = t("You can't moderate comments on contents you commented.");
  }

  if ($status & OWN_COMMENT) {
    $messages[OWN_COMMENT] = t("You can't moderate your own comment.");
  }

  if ($status & USER_CAN_MODERATE) {
    if (_slashcomments_get_mod_per_day) {
      $mod_points = slashcomments_get_user_mod_points($uid);
      if ($mod_points) {
        if ($mod_points == SLASHCOMMENTS_INFINITE_MOD_POINTS) {
          //$mod_points = t('unlimited');
          //$message = '';
        }
        else {
          $messages[USER_CAN_MODERATE] = t("You have !modpoints moderation points left.",
            array('!modpoints' => $mod_points));
        }
      }
      else {
        $sql = "SELECT assigned FROM {slashcomments_users_mod_points} WHERE uid = %d";
        $assigned = db_result(db_query($sql, $uid));

        $time_str = slashcomments_get_time_str(60*60*24 - (time() - $assigned));
        $messages[USER_CAN_MODERATE] = t("You don't have any moderation point. You'll get more in !timeleft.",
          array("!timeleft" => $time_str));
      }
    }
  }

  $result = array();
  if (count($filter)) {
    foreach ($filter as $v) {
      if ($messages[$v]) {
        $result[$v] = $messages[$v];
      }
    }
  }
  else {
    $result = $messages;
  }

  return $result;
}


/*
 * Returns days,  hours and minutes correspondings
 * to seconds in a given timestamp.
 *
 * @param $timestamp
 *  Seconds to be splitted in days, hours and minutes
 *
 * @return
 *  String representation of given seconds in the format
 *  x days y hours z minutes
 */
function slashcomments_get_time_str($timestamp) {
  $secs_per_day = 60*60*24;
  $secs_per_hour = 60*60;

  $days = (int)($timestamp / $secs_per_day);
  $timestamp -= $days * $secs_per_day;
  $hours = (int)($timestamp  / $secs_per_hour);
  $timestamp -= $hours * $secs_per_hour;
  $minutes = (int)($timestamp / 60);

  $output = "";
  if ($days) {
    $output .= $days . ' ' . t('Days');
  }
  if ($hours) {
    if ($days) $output .= ' ';
    $output .= $hours . ' ' . t('Hours');
  }
  if ($minutes) {
    if ($hours) $output .= ' ';
    $output .= $minutes . ' ' . t('Minutes');
  }
  return $output;
}

function slashcomments_node_has_slashcomments($node) {
  // Get the list of types that should use slashcomments
  $node_types = variable_get('slashcomments_node_types', array());
  return in_array($node->type, $node_types);
}


/*
 * Delete slashcomments data related to the specificied user.
 *
 * @param $uid
 *  User id of the affected user
 */
function delete_slashcomments_user_data($uid) {
  db_query("DELETE FROM {slashcomments_users_karma} WHERE uid = %d", $uid);
  db_query("DELETE FROM {slashcomments_users_mod_points} WHERE uid = %d", $uid);
  db_query("DELETE FROM {slashcomments_users_stats} WHERE uid = %d", $uid);
  db_query("DELETE FROM {slashcomments_users_notifications} WHERE uid = %d", $uid);
}
